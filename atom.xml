<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Helianthus</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-02T02:34:13.327Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Helianthus W</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Collection - 集合概述</title>
    <link href="http://yoursite.com/2019/07/02/java_collections_01/"/>
    <id>http://yoursite.com/2019/07/02/java_collections_01/</id>
    <published>2019-07-02T02:34:13.322Z</published>
    <updated>2019-07-02T02:34:13.327Z</updated>
    
    <content type="html"><![CDATA[<pre><code>在实际的项目开发中会有很多的对象，如何高效、方便地管理对象，成为影响程序性能与可维护性的重要环节。java提供了集合框架来解决此类问题，线性表、链表、哈希表等是常用的数据结构，在进行java开发时，JDK已经为我们提供了一系列相应的类来实现基本的数据结构，所有类都在java.util这个包里，如下，简单描述了集合类的关系：</code></pre><p>Collection</p><ol><li><p>List</p><ul><li>LinkedList</li><li>ArrayList</li><li>Vector<ul><li>Stack</li></ul></li></ul></li><li><p>Set</p></li></ol><p>Map</p><ol><li>HashTable</li><li>HashMap</li><li>WeakHashMap</li></ol><h5 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h5><pre><code>CollectionCollection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素(Elements)。一些Collection允许相同的元素、支持对元素进行排列，另一些则不行。JDK不提供直接继承自Collection的类，JDK提供的类都是继承自Collection子接口，如List和Set。所有实现Collection接口的类都必须提供两个标准的构造函数，无参数的构造函数用于创建一个空的Collection，有个Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素，后一个构造函数允许用户复制一个Collection。</code></pre><h6 id="如何遍历Collection中的每一个元素"><a href="#如何遍历Collection中的每一个元素" class="headerlink" title="如何遍历Collection中的每一个元素"></a>如何遍历Collection中的每一个元素</h6><pre><code>不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection的每一个元素。典型用法如下：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = collection.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Object object = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Collection接口派生出来的两个接口是List和Set。"><a href="#Collection接口派生出来的两个接口是List和Set。" class="headerlink" title="Collection接口派生出来的两个接口是List和Set。"></a>Collection接口派生出来的两个接口是List和Set。</h6><ol><li><p>List接口</p><p> List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引(元素在List中的位置，类似于数组下标)来访问<br> List中的元素，这类似与java的数组，和Set不同的是，List允许有重复的元素。除了具有Collection接口必备的iterator()方法外，List还提供了一个listIterator()方法，返回一个ListIterator接口。和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加、删除、设定元素、向前或向后遍历等功能。实现List接口的常用类有LinkedList，ArrayList,Vector和Stack等。</p></li></ol><h6 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h6><pre><code>Map没有继承Collection接口。Map提供了Key到Value的映射，一个Map中不能包含相同的Key，每个Key只能映射一个Value。Map接口提供了3种集合的视图，Map的内容可以被当做一组Key集合，一组Value集合，或者一组Key-Value映射。</code></pre><h6 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h6><pre><code>RandomAccess接口是一个标志接口，本身并没有提供任何方法，任何凡是通过调用RandomAccess接口的对象都可以认为是支持快速随机访问的对象。此接口的主要目的是表示那些可支持快速随机访问的List实现。任何一个基于数组的List实现都实现了RandomAccess接口，而基于链表的实现则都没有。因为只有数组能够进行快速的随机访问，而对于链表的随机访问需要进行链表的遍历。因此，此接口的好处是，可以在应用程序中知道正在处理的List对象是否可以进行快速随机访问，从而针对不同的List进行不同的操作，以提高程序的性能。</code></pre><h5 id="集合类介绍"><a href="#集合类介绍" class="headerlink" title="集合类介绍"></a>集合类介绍</h5><blockquote><p>LinkedList</p></blockquote><pre><code>LinkedList实现了List接口，允许Null元素。此外LinkedList提供额外的Get、Remove、Insert等方法在LinkedList的首部或尾部操作数据。这些操作使得LinkedList可被用作堆栈(Stack)、队列(Queue)、或者双向队列(Deque)。需要注意的是，LinkedList没有同步方法，它不是线程同步的，即如果多个线程同时访问一个List，则必须自己实现访问同步，一种解决方法是在创建List时构造一个同步的List，如下：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure><blockquote><p>ArrayList</p></blockquote><pre><code>ArrayList实现了可变大小的数组。它允许所有元素，包括Null。size、isEmpty、get、set等方法的运行时间为常数，但是add方法的开销为分摊的常数，添加N个元素需要O(N)的时间，其他的方法运行时间为线性。每个ArrayList实例都有一个容量(Capacity)，用于存储元素的数组的大小，这个容量可随着不断添加新元素而自动增加。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。和LinkedList一样，ArrayList也是线程非同步的。</code></pre><blockquote><p>Vector</p></blockquote><pre><code>Vector非常类似于ArrayList，区别是Vector是线程同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态(例如，添加或删除了一些元素)，这时调用Iterator的方法将抛出ConcurrentModificationException，因此必须捕获该异常。</code></pre><blockquote><p>Stack</p></blockquote><pre><code>Stack继承自Vector，实现了一个后进先出的堆栈。Stack提供了5个额外的方法使得Vector得以被当做堆栈使用。除了基本的Push和Pop方法，还有Peek方法得到栈顶的元素，Empty方法测试堆栈是否为空，Search方法检测一个元素在堆栈中的位置。注意，Stack刚创建后是空栈。</code></pre><blockquote><p>Set</p></blockquote><pre><code>Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2) = false。Set最多有一个Null元素。Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。请注意，必须小心操作可变对象(Multable Object)，如果一个Set中可变元素改变了自身状态，这可能会导致一些问题。</code></pre><blockquote><p>HashTable</p></blockquote><pre><code>HashTable继承Map接口，实现了一个基于Key-Value映射的哈希表。任何非空(not null)的对象都可作为Key或者Value。添加数据使用Put(key, value)，取出数据使用Get(key)，这两个基本操作的时间开销为常数。HashTable是通过Initial Capacity和Load Factor两个参数调整性能，通常缺省的Load Factor为0.75较好的实现了时间和空间的均衡，增大Load Factor可以节省空间但是响应的查找时间将增大，会影响get或put这样的操作。由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此，任何作为key的对象都必须实现hashCode和equals方法。hashCode和equals方法继承自根类Object，如果你用自定义类当做key的话，要相当小心，按照散列函数的定义，如果两个对象相同，即object1.equals(object2) = true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如果两个不同对象的hashCode相同，这种现象称之为冲突，冲突会导致操作哈希表的时间开销增加，所以尽量定义好的hashCode，能加快哈希表的操作。如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果(期待的get方法返回null)，要避免这种问题，最好同时复写equals方法和hashCode方法，而不是只写其中一个。</code></pre><blockquote><p>HashMap</p></blockquote><pre><code>HashMap和HashTable类似，不同之处在于HashMap是线程非同步的，并且允许null，即NullValue和NullKey。但是将HashMap视为Collection时(values()方法可返回Collection)，其迭代子操作时间开销和HashMap容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者Load Factor参数设置过低。</code></pre><blockquote><p>WeakHashMap</p></blockquote><pre><code>WeakHashMap是一种改进的HashMap，它对Key实行“弱引用”，如果一个Key不再被外部引用，那么该Key可以被GC回收。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;在实际的项目开发中会有很多的对象，如何高效、方便地管理对象，成为影响程序性能与可维护性的重要环节。java提供了集合框架来解决此类问题，线性表、链表、哈希表等是常用的数据结构，在进行java开发时，JDK已经为我们提供了一系列相应的类来实现基本的数据结构，所
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于abstract class 和 interface</title>
    <link href="http://yoursite.com/2019/07/02/interface_abstract_01/"/>
    <id>http://yoursite.com/2019/07/02/interface_abstract_01/</id>
    <published>2019-07-02T02:34:13.268Z</published>
    <updated>2019-07-02T02:34:13.272Z</updated>
    
    <content type="html"><![CDATA[<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><pre><code>在面向对象的概念中，我们知道所有的对象都是通过类来描绘的，但是反过来却不是这样，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类往往用来表征我们在对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。比如：如果我们进行一个图像编辑软件的开发，就会发现问题领域存在着圆，三角形这样的一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域是不存在的，它就是一个抽象概念。正式因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。在面向对象领域，抽象类主要用来进行类型隐藏。我们可以构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，因此它可以是不允许修改的，同时，通过这个抽象体派生，也可以扩展此模块的行为功能。面向对象设计的最核心原则OCP，抽象类是其中的关键所在。(OCP - Open - Closed - Principle)</code></pre><blockquote><p>从语法定义层面看abstract class和interface</p></blockquote><pre><code>在abstract class方式中，类可以有自己的数据成员，也可以有非abstract的成员方法，而在interface中，只能有静态的不能被修改的数据成员(也就是必须是static final的，不过在interface中一般不定义数据成员)，所有的成员方法都是abstract的。从某种意义上说，接口是一种特殊意义的抽象类。</code></pre><blockquote><p>从编程层面看abstract class和interface</p></blockquote><pre><code>首先，abstract class在java语言中表示的是一种继承关系，一个类只能使用一次继承关系，但是，一个类却可以实现多个interface。其次，在abstract class的定义中，我们可以赋予方法的默认行为。但是在interface定义中，方法却不能拥有默认行为，为了绕过这个限制，必须使用委托，但是这会增加一些复杂性，又是也会造成很大的麻烦。在抽象类中不能定义默认行为还存在另一个比较严重的问题，那就是可能会造成维护上的麻烦，因为如果后来想修改类的界面(一般通过abstract class或者interface来表示，)以适应新的情况时(比如，添加新的方法或者给已用的方法中添加新的参数)时，就会非常的麻烦，可能需要花费比较多的时间(对于派生类很多的情况，尤为如此)。但是如果界面是通过abstract class来实现的，那么可能就只需要修改定义在abstract class中的默认行为就可以了。同样，如果不能再抽象类中定义默认行为，就会导致同样的方法实现出现在该抽象类的每一个派生类中，违反了“one rule，one place”原则，造成代码重复，同样不利于以后的维护。因此，在abstract class和interface间进行选择时要非常的小心。</code></pre><blockquote><p>从设计理念层面看abstract class和interface</p></blockquote><pre><code>abstract class在java语言中体现了一种继承关系，要想使得继承关系合理，父类和派生类之间就必须存在“is a”关系，即父类和派生类在概念本质上应该是相同的。对于interface则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。下面通过一个简单的实例来说明。考虑这样一个例子，假设在我们的问题领域中有一个关于Door的抽象类型，该Door具有执行两个动作open()和close()，此时我们可以通过abstract class或者interface来定义一个表示该抽象概念的类型，定义方式分别如下：</code></pre><ol><li><p>使用abstract class来定义Door</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用interface来定义Door</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 具体的Door类型可以extends使用abstract class方式定义Door或者implements使用interface方式定义的Door。从以上看起来似乎没有太大<br> 的区别。现在，我们要求Door还要具备报警的功能,那么该如何设计该例子的类结构呢？</p></li></ol><h6 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h6><ol><li><p>在abstract class中增加一个alarm()方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在interface中增加一个alarm()方法，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 那么具备报警功能的AlarmDoor的定义方式如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">close</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>或者</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">implements</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;...&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这种方法违反了面向对象设计中的一个核心原则ISP(Interface Segregation Priciple)，在Door的定义中把Door概念本身固有的行为和另一个概念“报警器”的行为方法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为“报警器”这个概念的改变而改变，反之亦然。</code></pre><h6 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h6><pre><code>既然open()，close()和alarm()属于两个不同的概念，根据ISP原则应该把它们分别定义在代表这两个概念的抽象类中。定义方式有：这两个概念都使用abstract class定义；两个概念都使用interface方式定义；一个概念使用abstract方式定义，另一个概念使用interface方式定义由于java语言不支持多重继承，所以两个概念都使用abstract class方式定义是不可行的，后面两种方式都是可行，但是对于它们的选择却反映出对于问题领域中的概念本质的理解、对于设计意图的反应是否正确、合理。如果两个概念都使用interface方法来定义，那么就反映出两个问题：</code></pre><ol><li><p>我们可能没有理解清楚问题领域，AlarmDoor在概念本质上到底是Door还是报警器？</p></li><li><p>如果我们对于问题领域的理解没有问题，比如我们通过对于问题领域的分析发现AlarmDoor在概念本质上和Door是一致的，那么我们在实现时就没有正确的揭示我们的设计意图，因为在这两个概念定义上(均使用interface方式定义)反映不出上述含义。</p><p> 如果我们对于问题领域的理解是：AlarmDoor在概念本质上是Door，同时它又具有报警的功能。我们该如何设计设计、实现来明确的反映出我们的意思？abstract class在java语言中表示一种继承关系，而继承关系在本质上是“is a”关系。所以对于Door这个概念，我们应该使用abstractclass方式来定义。另外，AlarmDoor又具有报警功能，说明它又能够完成报警概念中定义的行为，所以报警概念可以通过interface方式定义，如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实abstract class表示的是“is a”关系，interface表示的是“like a”关系。abstract class和interface是java语言中的两种定义抽象类的方式，它们之间有很大的相似性。但是对于它们的选择却又往往反映出对于问题领域中的概念本质的理解、对于设计意图的反映是否正确、合理，因为它们表现了概念间的不同关系(虽然都能够实现需求的功能)。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;在面向对象的概念中，我们知道所有的对象都是通过类来描绘的，但是反过来却不是这样，并不是所有的类都是用来描绘对象的，如
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库存储</title>
    <link href="http://yoursite.com/2019/06/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2019/06/28/数据库存储/</id>
    <published>2019-06-28T11:24:19.170Z</published>
    <updated>2019-07-02T02:34:13.613Z</updated>
    
    <content type="html"><![CDATA[<h5 id="索引-帮助MySQL高效获取数据的数据结构"><a href="#索引-帮助MySQL高效获取数据的数据结构" class="headerlink" title="索引 -  帮助MySQL高效获取数据的数据结构"></a>索引 -  帮助MySQL高效获取数据的数据结构</h5><blockquote><p>常见的查询算法：</p></blockquote><ol><li>顺序查找</li><li>二分查找</li><li>二叉排序树查找</li><li>哈希散列法</li><li>平衡多路搜索树B树</li></ol><blockquote><p>常见索引原则</p></blockquote><ol><li>选择唯一性索引</li><li>为经常需要排序、分组和联合操作的字段建立索引</li><li>为常作为查询条件的字段建立索引</li><li>限制索引的数目</li><li>尽量使用数据量少的索引</li><li>尽量使用前缀来索引</li><li>删除不再使用或者甚少使用的索引</li><li>最左前缀匹配原则是非常重要的原则</li><li>尽量选择区分度高的列作为索引</li><li>索引列不能参与计算，保持列的“干净”：带函数的查询不参与索引</li><li>尽量扩展索引而不是新建索引</li></ol><h5 id="范式-最小冗余的表结构"><a href="#范式-最小冗余的表结构" class="headerlink" title="范式 最小冗余的表结构"></a>范式 最小冗余的表结构</h5><blockquote><p>第一范式 列都是不可再分的</p></blockquote><pre><code>第一范式的目标是确保每列的原子性，如果每列都是不可再分的最小数据单元，则满足第一范式</code></pre><blockquote><p>第二范式 每个表只描述一件事</p></blockquote><pre><code>第二范式在满足第一范式的基础上，要求表中的非主键列不存在对主键的部分依赖，第二范式要求每个表只描述一件事情</code></pre><blockquote><p>第三范式 不存在对非主键的传递依赖</p></blockquote><pre><code>第三范式在满足第二范式的基础上，要求表中的列不存在对非主键列的传递依赖。</code></pre><h5 id="事务-单个逻辑单元的系列操作"><a href="#事务-单个逻辑单元的系列操作" class="headerlink" title="事务 单个逻辑单元的系列操作"></a>事务 单个逻辑单元的系列操作</h5><blockquote><p>事务的属性</p></blockquote><ol><li>原子性</li><li>一致性</li><li>隔离性</li><li>永久性</li></ol><blockquote><p>数据库锁</p></blockquote><ol><li>行级锁<br> 行级锁是一种排它锁，防止其他事务修改此行</li><li>表级锁<br> 表级锁是对当前操作的整张表加锁，它实现简单，资源消耗较少。表级锁定分为表共享读锁(共享锁)与表独占写锁(排它锁)</li><li>页级锁<br> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但是冲突多，行级锁冲突少，但是速度慢。因此折中一下将锁的粒度调整为页级，一次锁定相邻的一组记录。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;索引-帮助MySQL高效获取数据的数据结构&quot;&gt;&lt;a href=&quot;#索引-帮助MySQL高效获取数据的数据结构&quot; class=&quot;headerlink&quot; title=&quot;索引 -  帮助MySQL高效获取数据的数据结构&quot;&gt;&lt;/a&gt;索引 -  帮助MySQL高效获取数据的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线程池和工作队列</title>
    <link href="http://yoursite.com/2019/06/28/threadpool_01/"/>
    <id>http://yoursite.com/2019/06/28/threadpool_01/</id>
    <published>2019-06-28T11:24:19.138Z</published>
    <updated>2019-07-02T02:34:13.564Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为什么要使用线程池</p></blockquote><pre><code>诸如web服务器、数据库服务器、文件服务器或邮件服务器之类的许多服务器应用程序都面向处理来自某些远程来源的大量短小的任务，服务器应用程序中经常出现的情况是：单个任务处理的时间很短而请求的数目是巨大的。构建服务应用程序一个简单的模型应该是：每当一个请求到达就创建一个新线程，然后在新线程中为请求服务。如果以这样的方式部署服务器应用程序，那么其不足也是比价明显的：</code></pre><ul><li><p>为每个请求创建一个新线程的开销很大</p></li><li><p>为每个请求创建新线程的服务器在创建和销毁线程上花费的时间和消耗的系统资源要比花在处理实际的用户请求的时间和资源更多</p></li><li><p>在一个JVM中创建大量的线程可能会导致系统由于过度消耗内存而用完内存或“切换过度”</p><p>  线程池为线程生命周期开销问题和资源不足提供了解决方案，通过对多个任务重用线程，线程的创建的开销被分摊到多个任务上。其好处是，当请求到达时线程已经存在，也就消除了线程创建所带来的的延迟，使得响应更快；通过适当的调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其他任何新到的请求一直等待，直到获得一个线程来处理为止，从而防止资源不足。</p></li></ul><blockquote><p>使用线程池的风险</p></blockquote><pre><code>虽然线程池是构建多线程应用程序的强大机制，但使用它并不是没有风险的。用线程池构建的应用程序容易遭受任何其他多线程应用程序容易遭受的所有并发风险，诸如同步错误和死锁，它还容易遭受特定于线程池的少数其他风险，诸如与池有关的死锁、资源不足和线程泄露。</code></pre><h6 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h6><pre><code>任何多线程应用都有死锁风险。当一组进程或线程中的每一个都在等待一个只有该组中另一个进程才能引起的事件时，我们就说这组进程或线程死锁了。死锁的最简单的情形是： 线程A持有对象X的独占锁，并且在等待对象Y的锁，而线程B持有对象Y的独占锁，却在等待对象X的锁。除非有某种方法来打破对锁的等待(Java锁定不支持这样的方法)，否则死锁的线程将永远等下去。虽然任何多线程程序中都有死锁的风险，但线程池却引入了另一种死锁的可能，所有池线程都在执行已阻塞的等待队列中另一任务的执行结果的任务，但是这一任务却因为没有未被占用的线程而不能执行。当线程池被用来实现涉及许多交互对象的模拟，被模拟的对象可以相互发送查询，这些查询接下来作为排队的任务执行，查询对象有同步等待着响应，就会发生这种情况。</code></pre><h6 id="资源不足"><a href="#资源不足" class="headerlink" title="资源不足"></a>资源不足</h6><pre><code>线程池的一个优点在于： 相对于其他替代调度机制而言，他们通常执行的很好，但是只有恰当的调整了线程池的大小时才是这样。线程消耗包括内存和其他系统资源在内的大量资源。除了Thread对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM可能会为每个java线程创建一个本机线程，这些本机线程将会消耗额外的系统资源，最后，虽然线程之间切换的调度开销很小，但如果有很多线程，环境切换也可能严重地影响程序的性能。如果线程池太大，那么那些被线程消耗的资源可能严重的影响系统性能。在线程之间进行切换将会浪费时间，而且使用超出比您实际需要的线程可能会引起资源匮乏的问题，因为池线程正在消耗一些资源，而这些资源可能会被其他任务更有效的利用。除线程自身所使用的资源以外，服务请求时所做的工作可能需要其他资源，例如JDBC连接、套接字或者文件，这些也是有限资源，有太多的的并发请求也可能会引起失效，例如不能分配JDBC连接。</code></pre><h6 id="并发错误"><a href="#并发错误" class="headerlink" title="并发错误"></a>并发错误</h6><pre><code>线程池和其他排队机制依靠使用wait()和notify()方法，这两个方法都难于使用。如果编码不正确，那么可能丢失通知，导致线程保持空闲状态，尽管队列中有工作要处理。</code></pre><h6 id="线程泄露"><a href="#线程泄露" class="headerlink" title="线程泄露"></a>线程泄露</h6><pre><code>各种类型的线程池中一个严重的风险是线程泄露，当从池中派出一个线程执行一项任务，而在任务完成后该线程却没有返回池时，会发生这种情况。发生线程泄露的一种情形出现在任务抛出一个RuntimeException或一个Error时，如果池类没有捕获到它们，那么线程只会退出而线程池的大小将永久减少一个。当这种情况发生的次数足够多时，线程池最终就为空了，而且系统将停止，因为没有可用的线程来处理任务。有些任务可能会永久停止等待某些资源或来自用户的输入，而这些资源又不能保证可用，诸如此类的任务将会永久停止，而这些停止的任务也会引起和线程池泄露的同样的问题，如果某个线程被这样一个任务永久消耗着，那么它实际上就被从池中除去了。对于这样的任务，应该要么只给予它们自己的线程，要么只让它们等待有限的时间。</code></pre><h6 id="请求过载"><a href="#请求过载" class="headerlink" title="请求过载"></a>请求过载</h6><pre><code>仅仅是请求就压垮了服务器，这种情况是有可能出现的。在这种情形下，我们可能不想将每个到来的请求都排队到我们的工作队列，因为排在队列中等待执行的任务可能会消耗太多的系统资源并引起资源匮乏，这种情况下如何做取决于开发者的处理策略，在某些情况下，可以简单的抛弃请求，依靠更高级别的协议稍后重试请求，也可以用一个指出服务器暂时很忙的响应来拒绝请求。</code></pre><h6 id="调整线程池的大小"><a href="#调整线程池的大小" class="headerlink" title="调整线程池的大小"></a>调整线程池的大小</h6><ol><li><p>调整线程池的大小基本是避免两类错误：线程太少或者线程太多。在运行具有N个处理器机器上的计算限制的应用程序中，在线程数目接近N时添加额外的线程可能会改善总处理能力，而在线程数目超过N时添加额外的线程将不起作用。事实上，太多的线程甚至会降低性能，因为它会导致额外的环境切换开销。</p></li><li><p>线程池的最佳大小取决于可用处理器的数目以及工作队列中的任务的性质。</p><ul><li>若在一个具有N个处理器的系统上只有一个工作队列，其中全是计算性质的任务，在线程池具有N或者N+1个线程时一般会获得最大的CPU利用率。</li><li>对于那些可能需要等待I/O完成的任务，需要让池的大小超过可用处理器的数目，因为并不是所有的线程一直在工作。通过预估某个典型请求的等待时间(WT) 与服务时间(ST)之间的比例，那么对于一个具有N个处理器的系统，需要设置大约N*(1+WT/ST)个线程来保持处理器得到充分利用。</li></ul></li><li><p>处理器的利用率不是调整线程池大小的唯一考虑项。随着线程池的增长，可能会遇到调度程序、可用内存方面的限制，或者其他系统资源方面的限制。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;为什么要使用线程池&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;诸如web服务器、数据库服务器、文件服务器或邮件服务器之类的许多服务器应用程序都面向处理来自某些远程来源的大量短小的任务，服务器应用程序中经常出现的情况是：单个任务处理的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Framework 第01篇</title>
    <link href="http://yoursite.com/2019/06/28/spring_framework_01/"/>
    <id>http://yoursite.com/2019/06/28/spring_framework_01/</id>
    <published>2019-06-28T11:24:19.123Z</published>
    <updated>2019-07-02T02:34:13.546Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Spring总共有十几个组件，但是真正核心的组件只有几个。在Spring框架中核心组件包括：Core、Context和Beans。</code></pre><h5 id="Spring的设计理念"><a href="#Spring的设计理念" class="headerlink" title="Spring的设计理念"></a>Spring的设计理念</h5><pre><code>如果在Core、Context、Beans中在选择出一个核心组件的话，那么就非Beans组件莫属了，Spring其实可以说是面向Bean的编程了。Bean在Spring中的作用就像Object对OOP的意义一样，没有对象的概念就没有面向对象的编程了。Spring解决了一个非常关键的问题，它可以让你把对象之间的依赖关系转而用配置文件来管理，也就是依赖注入机制。而这个注入关系在一个叫做IOC的容器中管理，IOC容器就是被Bean包裹的对象，Spring正是通过把对象包装在Bean中而达到对这些Bean对象的管理以及一些列额外操作的目的。这种设计策略完全类似于java实现OOP的设计理念。当然java本身的设计要比Spring复杂太多太多，但是都是构建一个数据结构，然后根据这个数据结构设计它的生存环境，并让它在这个生存环境中按照一定的规律在不停的运动，在它们的 不停运动中设计一系列与环境或者与其他个体完成信息交换。</code></pre><h5 id="核心组件如何协同工作"><a href="#核心组件如何协同工作" class="headerlink" title="核心组件如何协同工作"></a>核心组件如何协同工作</h5><pre><code>Bean包装的是Object，而Object必然有数据，如何给这些数据提供生存环境就是Context要解决的问题，对于Context来说它就是要发现每个Bean之间的关系，为它们建立这种关系并且要维护好这种关系。所以Context就是一个Bean关系的集合，这个关系集合又叫IOC容器，一旦建立起这个IOC容器后Spring就可以为你工作了。Core组件是发现，建立和维护每个Bean之间的关系所需要的一系列的工具，从这个角度来看，Core这个组件是叫做Util更容易理解。</code></pre><h5 id="核心组件详解"><a href="#核心组件详解" class="headerlink" title="核心组件详解"></a>核心组件详解</h5><blockquote><p>Bean组件</p></blockquote><pre><code>Bean组件位于Spring的org.springframework.beans包下，这个包下的所有类主要解决了三件事：Bean的定义、Bean的创建以及对Bean的解析，对于Spring的使用者来说唯一需要关心的就是Bean的创建，其余的操作由Spring自己内部完成，对上层调用者来说是透明的。Spring Bean的创建是典型的工厂模式，它的顶级接口是BeanFactory。BEANFactory有三个子类：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory，而最终的默认实现类是DefaultListableBeanFactory是实现了所有的接口。每个接口都有使用的场合，它主要是为了区分在Spring内部对象的传递和转化过程中，对对象的数据访问所做的限制。如ListableBeanFactory接口表示这些Bean是可列表的，而HierarchicalBeanFactory表示这些类是有继承关系的，AutowireCapableBeanFactory接口定义了Bean的自动装配规则。Bean的定义主要是由BeanDefinition描述。Bean的定义就是完整的描述了在Spring的配置文件中定义的&lt;bean/&gt;节点中所包含的信息，包括各种子节点。当Spring成功解析定义的一个&lt;Bean/&gt;节点后，在Spring内部就被转化成BeanDefinition对象，以后所有的操作都是对这个对象完成的。</code></pre><blockquote><p>Context组件</p></blockquote><pre><code>Context组件在Spring的org.springframework.context包下，Context实际就是给Spring提供了一个运行环境，用以保存各个对象的状态。ApplicationContext是Context的顶级父类，它除了能标识一个应用环境的基本信息外，还继承了五个接口，这五个接口主要是扩展了Context的功能。继承BeanFactory说明了Spring容器中运行的主体对象是Bean，继承了ResourceLoader，使得ApplicationContext可以访问到任何外部资源。ApplicationContext的子类主要包含两个方面：</code></pre><ol><li><p>ConfigurableApplicationContext表示该Context是可修改的，也就是在构建Context中用户可以动态添加或修改已有的配置信息，它下面又有多个子类，其中最常使用的是可更新的Context，即AbstractRefreshableApplicationContext。</p></li><li><p>WebApplicationContext即为web准备的Context，可以直接访问ServletContext，通常情况下，这个接口使用的少。</p><p> ApplicationContext必须要完成一下几件事情：</p></li></ol><ul><li><p>表示一个应用环境</p></li><li><p>利用BeanFactory创建对象</p></li><li><p>保存对象关系表</p></li><li><p>能够捕获各种事件</p><p>  Context作为Spring的IOC容器，基本上整合了Spring的大部分功能。</p></li></ul><blockquote><p>Core组件</p></blockquote><pre><code>Core作为Spring的核心组件，其中包含了很多的关键类，其中一个重要的组成部分就是定义了资源的访问方式。它使用Resource接口封装了各种可能的资源类型，对使用者来说屏蔽了文件类型的不同。对资源的提供者来说，如何把资源包装起来交给其他人使用这是一个问题，Resource接口继承了InputStreamSource接口，这个接口中有个getInputStream方法，返回一个InputStream类，这样所有的资源都可以通过InputStream这个类来获取，所以也屏蔽了资源的提供者。另外还有一个问题是加载资源的问题，也就是资源的加载者需要统一，这个任务是由ResourceLoader接口完成的，它屏蔽了所有资源加载者的差异，只需要加载这个接口就可以加载所有的资源，它的默认实现是DefaultResourceLoader。Context把资源的加载、解析和描述工作委托给了ResourcePatternResolver类来完成，它相当于一个接头人，它把资源的加载、解析和资源的定义整合在一起便于其他组件使用。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;Spring总共有十几个组件，但是真正核心的组件只有几个。在Spring框架中核心组件包括：Core、Context和Beans。&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;Spring的设计理念&quot;&gt;&lt;a href=&quot;#Spring的设计理念&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NIO 概述01</title>
    <link href="http://yoursite.com/2019/06/28/java_nio_01/"/>
    <id>http://yoursite.com/2019/06/28/java_nio_01/</id>
    <published>2019-06-28T11:24:18.967Z</published>
    <updated>2019-07-02T02:34:13.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为什么要使用NIO？</p></blockquote><pre><code>NIO创建的目的是为了让java程序员可以实现高速I/O而无需编写自定义的本地代码。NIO将最耗时的I/O操作(即填充和提取缓冲区)转移回操作系统，因而可以极大的提高速度。</code></pre><h5 id="通道和缓冲区-NIO的核心"><a href="#通道和缓冲区-NIO的核心" class="headerlink" title="通道和缓冲区 - NIO的核心"></a>通道和缓冲区 - NIO的核心</h5><pre><code>通道是对原I/O包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个channel对象。一个Buffer实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样的，从通道中读取的任何数据都要读到缓冲区中。</code></pre><blockquote><p>什么是缓冲区</p></blockquote><pre><code>Buffer是一个对象，它包含一些要写入或者刚读出的数据。在NIO中加入Buffer对象，体现了新库与原I/O的一个重要的区别。在面向流的I/O中，您将数据直接写入或者将数据直接读到Stream对象中。在NIO库中，所有的数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问NIO中的数据，都是将它们放到缓冲区中。缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</code></pre><blockquote><p>缓冲区类型</p></blockquote><pre><code>最常用的缓冲区类型是ByteBuffer。一个ByteBuffer可以在在其底层数组上进行get/set操作(即字节的获取和设置)。对于每一种基本java类型都有一种缓冲区类型：</code></pre><ul><li><p>ByteBuffer</p></li><li><p>CharBuffer</p></li><li><p>ShortBuffer</p></li><li><p>IntBuffer</p></li><li><p>LongBuffer</p></li><li><p>FloatBuffer</p></li><li><p>DoubleBuffer</p><p>  每一个Buffer类都是Buffer接口的一个实例。除了ButeBuffer，每个Buffer类都有完全一样的操作，只是他们所处理的数据类型不一样。因为大多数标准I/O操作都是用ByteBuffer，所以它具有所有共享的缓冲区操作以及一些特有的操作。</p></li></ul><blockquote><p>什么是通道</p></blockquote><pre><code>Channel是一个对象，可以通过它读取和写入数据。拿NIO与原来的I/O做个比较，通道就像是流。</code></pre><blockquote><p>通道类型</p></blockquote><pre><code>通道与流的不同之处在于通道是双向的。而流只是在一个方向是移动(一个流必须是InputStream或者OutputStream的子类)，而通道可以用于读、写或者同时用于读写。因为它们是双向的，所以通道可以比流更好的反应底层操作系统的真实情况。</code></pre><h5 id="状态变量和访问方法-重要的缓冲区组件"><a href="#状态变量和访问方法-重要的缓冲区组件" class="headerlink" title="状态变量和访问方法 - 重要的缓冲区组件"></a>状态变量和访问方法 - 重要的缓冲区组件</h5><pre><code>每一个读/写操作都会改变缓冲区的状态，通过记录和追踪这些变化，缓冲区就能够内部的管理自己的资源。</code></pre><blockquote><p>状态变量</p></blockquote><pre><code>缓冲区任意时刻的状态可用如下三个值指定：</code></pre><ul><li><p>position</p><p>  缓冲区实际上就是美化了的数组。再从通道读取时，所读取的数据放到底层的数组中。position变量跟踪已经写了多少数据，更准确的说，它指定了下一个字节将放到数组的哪一个元素中。同样能在写入通道时，从缓冲区获取数据。position值跟踪从缓冲区获取了多少数据，更准确的说，它指定下一个字节来自数组的哪一个元素。</p></li><li><p>limit</p><p>  limit变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。position总是小于<br>  或者等于limit。</p></li><li><p>capacity</p><p>  缓冲区的capacity表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小或者说至少指定了准许使用的底层数组的容量。<br>  limit绝对不能大于capacity。</p><p>  这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。</p></li></ul><h5 id="缓冲区分配和包装"><a href="#缓冲区分配和包装" class="headerlink" title="缓冲区分配和包装"></a>缓冲区分配和包装</h5><pre><code>在能够读和写之前，必须有一个缓冲区。要创建缓冲区，必须首先分配它。使用ByteBuffer.allocate()方法来分配缓冲区；通过使用ByteBuffer.wrap()方法将一个数组包装为缓冲区。必须小心进行这类操作。一旦完成包装，底层数据就可以通过缓冲区或者是直接访问。</code></pre><h5 id="缓冲区分片"><a href="#缓冲区分片" class="headerlink" title="缓冲区分片"></a>缓冲区分片</h5><pre><code>slice()方法可以根据现有缓冲区创建一种子缓冲区，也就说它创建了一个新的缓冲区，新的缓冲区与原来的缓冲区的一部分共享数据。当子缓冲区的数据发生变化时，原缓冲区中只有子缓冲区位置的数据被改变了。</code></pre><blockquote><p>只读缓冲区</p></blockquote><pre><code>只读缓冲区，顾名思义可以读取它们但是不能向它们写入。可以通过调用缓冲区的asReadOnlyBuffer()方法，将任何常规缓冲区转化为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。</code></pre><p><strong><em>只读缓冲区不能被转化为可写缓冲区</em></strong></p><blockquote><p>直接和间接缓冲区</p></blockquote><pre><code>直接缓冲区是为了加快I/O速度，以一种特殊的方式分配其内存缓冲区。给定一个直接字节缓冲区，java虚拟机将尽最大努力直接对它执行本机I/O操作。也就是说，它会在每一次调用底层操作系统的本机I/O操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。</code></pre><h5 id="内存映射文件I-O"><a href="#内存映射文件I-O" class="headerlink" title="内存映射文件I/O"></a>内存映射文件I/O</h5><pre><code>内存映射文件I/O是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的I/O快的多。内存映射文件I/O通过使文件中的数据神奇般的出现为内存数组的内容来完成。一般来说，只有文件中实际读取或者写入的部分才会送入(或者映射)到内存中，并不是将整个文件读到内存中。尽管创建内存映射文件比较简单，但是向它写入是危险的。仅只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件，修改数据和数据保存到磁盘是没有分开的。</code></pre><h5 id="分散和聚集"><a href="#分散和聚集" class="headerlink" title="分散和聚集"></a>分散和聚集</h5><pre><code>分散/聚集I/O是使用多个而不是单个缓冲区来保存数据的读写方法。一个分散的读取就像一个常规通道读取，只不过它是将数据读到一个缓冲区数组中而不是单个缓冲区中，同样的，一个聚集写入是向缓冲区数组而不是单个缓冲区写入数据。缓冲区的方便性对于缓冲区数组同样有效，每一个缓冲区都跟踪自己还可以接收多少数据，所以分散读取会自动找到有空间接收数据的第一个缓冲区。在这个缓冲区填满之后，它就会移动到下一个缓冲区。分散/聚集I/O对于将数据划分为几个部分很有用。例如在编写一个使用消息对象的网络应用程序，每一个消息被划分为固定长度的头部和固定长度的正文。可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容纳正文的缓冲区。将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。聚集写入对于把一组单独的缓冲区中组成单个数据流是很有用的。同样在一个使用消息对象的网络应用程序，可以使用聚集写入来自动将网络消息的各个部分组装为单个数据流，以便跨越网络传输消息。</code></pre><h5 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h5><pre><code>文件锁就像是常规的java对象锁，属于劝告式的锁。它们不阻止任何形式的数据访问，它们通过锁的共享和获取来允许系统的不同部分相互协调。通常可以锁定整个文件或者文件的一部分。如果获取的是一个排它锁，那么其他人就不能获得同一个文件或者文件的一部分上的锁。如果获取的是一个共享锁，那么其他人可以获得同一个文件或者文件一部分上的共享锁，但是不能获得排它锁。文件锁定并不总是处于保护数据的目的，例如可能临时锁定一个文件以保证特定的写操作称为原子的，而不会有其他程序的干扰。</code></pre><h6 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h6><pre><code>异步I/O是一种没有阻塞的读写数据的方法。通常，在代码进行read()调用时，代码会阻塞直至有可供读取的数据。同样，write()调用将会阻塞直至数据能够写入。而异步I/O调用不会阻塞，注册特定的I/O事件如可读的数据的到达、新的套接字连接等等，当发生这样的事件时，系统将会通知调用方。异步I/O的优势在于它允许同时根据大量的输入和输出执行I/O，同步程序常常要求助于轮询或者创建大量的线程已处理大量的连接。使用异步I/O，可以监听任意数量的通道上的事件，不用轮询，也不需要额外的线程。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;为什么要使用NIO？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;NIO创建的目的是为了让java程序员可以实现高速I/O而无需编写自定义的本地代码。NIO将最耗时的I/O操作(即填充和提取缓冲区)转移回操作系统，因而可以极大的提高速
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java i/o的工作机制</title>
    <link href="http://yoursite.com/2019/06/28/java_io_01/"/>
    <id>http://yoursite.com/2019/06/28/java_io_01/</id>
    <published>2019-06-28T11:24:18.951Z</published>
    <updated>2019-07-02T02:34:13.380Z</updated>
    
    <content type="html"><![CDATA[<pre><code>I/O问题是任何编程语言都无法回避的问题，可以说I/O问题是整个人机交互的核心问题，因为I/O是机器获取和交换信息的主要渠道。在java中可分为以下几种I/O操作类：</code></pre><ol><li><p>基于字节操作的I/O接口：InputStream和OutputStream</p></li><li><p>基于字符操作的I/O接口：Writer和Reader</p></li><li><p>基于磁盘操作的I/O接口：File</p></li><li><p>基于网络操作的I/O接口：Socket</p><p> 前两组主要是根据传输数据的数据格式，后两组主要是根据传输数据的方式，因此要么要么是数据格式影响I/O操作，要么是传输方式影响I/O操作。</p></li></ol><h5 id="基于字节的I-O操作接口"><a href="#基于字节的I-O操作接口" class="headerlink" title="基于字节的I/O操作接口"></a>基于字节的I/O操作接口</h5><pre><code>基于字节的I/O操作接口输入和输出分别是：InputStream和OutputStream。流最终要写到什么地方必须要指定，要么写到磁盘，要么写到网络，而写网络实际上也是写文件，只不过写网络还有一步需要处理的就是底层操作系统再将数据传送到其他地方而不是本地磁盘。</code></pre><h5 id="基于字符的I-O操作接口"><a href="#基于字符的I-O操作接口" class="headerlink" title="基于字符的I/O操作接口"></a>基于字符的I/O操作接口</h5><pre><code>不关是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以I/O操作的都是字节而不是字符。之所有存在操作字符的I/O接口是因为通常我们程序中操作的数据都是字符形式，为了操作方便直接提供了一个操作字符的接口。而字符到字节必须要经过转码，而这个转码有非常耗时，而且经常会出现乱码问题，所以I/O的编码问题是一个让人头疼的问题。</code></pre><h5 id="字节到字符的转化接口"><a href="#字节到字符的转化接口" class="headerlink" title="字节到字符的转化接口"></a>字节到字符的转化接口</h5><pre><code>数据持久化或网络传输都是以字节进行的，所以必须要有字节到字符或者是字符到字节的转化。InputStreamReader类是字节到字符转化的桥梁，InputStream到Reader的过程需要制定字符集，否则将采取操作系统默认的字符集，很可能会出现乱码。StreamDecoder是完成字节到字符的解码的实现类。而字符到字节的编码过程正是通过OutputStreamWriter类来完成，由StreamEncoder完成编码过程。</code></pre><h5 id="磁盘I-O工作机制"><a href="#磁盘I-O工作机制" class="headerlink" title="磁盘I/O工作机制"></a>磁盘I/O工作机制</h5><pre><code>对于数据写到何处这个关键问题，其中一个主要方式就是将数据持久化到物理磁盘。数据在磁盘的唯一最小描述就是文件，也就说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最下单元。在java中通常的File并不代表一个真实存在的文件对象，当指定一个路径描述符时，它就会返回一个代表这个路径相关联的虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。那么什么时候会检查一个文件存不存在，就是在真正要读取这个文件的时候。当传入一个文件路径时，将会根据这个路径创建一个File对象来标识这个文件，然后将会根据这个对象创建真正读取对象的操作对象，这时会真正创建一个关联真实存在的磁盘文件的文件描述符FileDescriptor，通过这个对象可以直接控制到 这个磁盘文件。由于我们需要读取的是字符格式，所以就需要StreamDecoder类将byte解码为char格式，至于如何从磁盘驱动器上读取一段数据，有操作系统帮助我们完成。至于操作系统如何将数据持久化到磁盘以及如何建立数据结构需要根据当前操作系统使用何种文件系统来回答。</code></pre><h5 id="JAVA-Socket工作机制"><a href="#JAVA-Socket工作机制" class="headerlink" title="JAVA Socket工作机制"></a>JAVA Socket工作机制</h5><pre><code>Socket这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信的一种抽象功能。Socket也分为很多种类，大部分情况下我们使用的都是基于TCP/IP的流套接字，它是一种稳定的通讯协议。</code></pre><blockquote><p>一个基于Socket通信的场景描述：</p></blockquote><pre><code>主机A的应用程序要能和主机B的应用程序通信，必须通过Socket建立连接，而建立Socket连接必须需要底层TCP/IP协议来建立连接。建立TCP连接需要底层IP协议来寻址网络中的主机。虽然在网络层可以通过IP协议来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通讯，就需要通过TCP或者是UDP的地址也就是端口号来指定。这样就能通过一个Socket实例唯一代表主机上的一个应用程序的通讯链路了。</code></pre><blockquote><p>建立通讯链路</p></blockquote><pre><code>当客户端要与服务端通讯，客户端首先要创建一个Socket实例，操作系统将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将进行TCP的三次握手协议，TCP握手协议完成后，Socket实例将创建完成，否则将抛出IOEexception。与之对应的服务端将创建一个ServerSocket实例，ServerSocket创建比较简单只要指定的端口号没有被占用，一般实例 创建都会成功，同时操作系统也会为ServerSocket创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下为“*”也就是监听所有地址。实例创建完成后，通过调用accept()方法进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构表中，此时服务端与客户端对应的Socket实例并没有创建完成，而是要等到与客户端的三次握手完成之后，这个服务端的Socket实例才会返回，并将这个Socket实例对应的数据结构从未完成列表中移到已完成列表中。所以ServerSocket所关联的列表中每个数据结构都代表与客户端建立的TCP连接。</code></pre><blockquote><p>数据传输</p></blockquote><pre><code>传输数据是我们建立连接的主要目的。当连接建立成功后，服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和OutputStream，正式通过这两个对象来交换数据。在网络中I/O都是以字节流传输的。当Socket对象创建时，操作系统将会为InputStream和OutputStream分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写入到OutputStream对应的SendQ队列中，当队列填满时，数据将被发送到另一端的InputStream的RecvQ队列中，如果这是RecvQ已经满了，那么OutputStream的write方法将会阻塞直到RecvQ队列有足够的空间容纳SendQ发送的数据。值得注意的是，这个缓存区大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络I/O与磁盘I/O在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁。</code></pre><h5 id="I-O调优"><a href="#I-O调优" class="headerlink" title="I/O调优"></a>I/O调优</h5><blockquote><p>磁盘I/O调优</p></blockquote><ol><li><p>性能检测</p><p> 判断I/O是否是一个瓶颈，部分参数指标可以参考：如压力测试应用程序看系统的I/O wait指标是否正常，理想的I/O wait参数不应该超过25%<br> ，如果超过25%的话,I/O很可能成为应用程序的性能瓶颈。<br> 通常判断I/O性能时还会查看另外一个参数就是IOPS。每个磁盘的IOPS通常是在一个范围内，这和存储在磁盘的数据块大小和访问方式也有关，但<br> 是主要是由磁盘的转速决定的，磁盘的转速越高，磁盘的IOPS也越高。<br> RAID技术理论IOPS的计算公式： IOPS = (磁盘数*每块磁盘的IOPS)/(磁盘读的吞吐量 + RAID因子 * 磁盘写的吞吐量)</p></li><li><p>提升I/O性能</p><ul><li>增加缓存，减少磁盘访问次数</li><li>优化磁盘的管理系统，设计最优的磁盘访问策略，以及磁盘的寻址策略(操作系统层面考虑的)</li><li>设计合理的磁盘存储数据块，以及访问这些数据块的策略(应用层面考虑的)，例如给存放数据设计的数据设计索引，通过寻址索引来加快和减少磁盘的访问，还有可以采用异步和非阻塞的方式加快磁盘的访问效率</li><li>应用合理的RAID策略提升磁盘IO(RAID0  RAID1 RAID5 RAID0+1)</li></ul></li></ol><blockquote><p>网络I/O优化</p></blockquote><pre><code>网络I/O优化通常的一些基本处理原则：</code></pre><ol><li>减少网络交互的次数</li><li>减少网络传输数据量的大小</li><li>尽量减少编码</li><li>根据应用场景设计合适的交互方式(包括同步，异步阻塞，非阻塞)</li></ol><h6 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h6><pre><code>所谓的同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成以后，依赖的任务才能算完成，这是一种可靠的任务序列，要么成功都成功，要么失败都失败，两个任务的状态可以保持一致。而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务完成什么工作，依赖的任务也立即执行，只要自己完成了，整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</code></pre><h6 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h6><pre><code>阻塞与非阻塞主要是从CPU的消耗上来说的，阻塞就是CPU停下来等待一个慢的操作完成才接着完成其他的事情。非阻塞就是这个慢的操作在执行时CPU去做其他的事情，等这个慢的操作完成时，CPU在接着完成后续的操作。虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，但是也带来了另外一种后果就是系统的线程切换增加。增加的CPU使用时间能不能补偿系统的切换成本需要好好评估。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;I/O问题是任何编程语言都无法回避的问题，可以说I/O问题是整个人机交互的核心问题，因为I/O是机器获取和交换信息的主要渠道。在java中可分为以下几种I/O操作类：&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基于字节操作的I/O接口：InputStr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程编程</title>
    <link href="http://yoursite.com/2019/06/28/java_concurrent_01/"/>
    <id>http://yoursite.com/2019/06/28/java_concurrent_01/</id>
    <published>2019-06-28T11:24:18.935Z</published>
    <updated>2019-07-02T02:34:13.345Z</updated>
    
    <content type="html"><![CDATA[<pre><code>并发编程提供了不论是在单一操作系统上还是分布在大量系统上的操作的同时执行。这类操作实际上是一些指令顺序，例如单独某个顶级任务的子任务，这类操作能够并行执行，或者作为线程，或者作为进程。线程和进程之间的本质区别在于：进程通常是独立的(例如有独立的地址空间)，所以只能通过系统提供的进程间通讯机制进行交互，而线程通常共享单一进程的状态信息，能够直接共享系统资源和内存中的对象。</code></pre><h5 id="线程安全性和同步"><a href="#线程安全性和同步" class="headerlink" title="线程安全性和同步"></a>线程安全性和同步</h5><pre><code>如果java对象中的某个方法能够安全的运行在多线程环境中，那么就称该方法是线程安全的。要获得这种安全性，必须有一种机制，通过该机制，运行同一个方法的多个线程就能够同步其操作，这样，在访问相同的对象或代码行时，就会只允许一个线程来处理。这种同步要求线程使用叫做信号的对象彼此进行沟通。有一种类型的信号叫做互斥信号或互斥体，顾名思义，这个信号对象的拥有权是互斥的，也就是说，在任意指定期间，只有一个线程能够拥有互斥体，其他想获得所有权的线程会被阻塞，它们必须等待，直到拥有互斥体的线程释放互斥体。如果多个线程按照顺序排队等候同一互斥体，那么当前拥有者释放它的时候，只有一个等待线程能够得到它，其他线程将继续阻塞。</code></pre><h5 id="等候和通知"><a href="#等候和通知" class="headerlink" title="等候和通知"></a>等候和通知</h5><pre><code>wait/notify构造在java语言的线程间通信机制中也扮演了重要的角色。基本的想法是：一个线程需要的某个条件可以由另外一个线程促成。这样条件的wait就可以得到满足，一旦条件为真，那么引发条件的线程就会notify等候线程苏醒，并从终止的地方继续进行。wait/notify机制要比synchronized机制更难理解和判断。要想判断出使用wait/notify的方法的行为逻辑，就要求判断出使用它的所有方法的逻辑。一次判断一个方法，把该方法和其他方法隔离开，是对整体系统行为得出错误结论的可靠方式。显然，这样做的复杂性会随着要判断的方法的数量增长而迅速提高。</code></pre><h5 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h5><pre><code>典型的操作系统支持两种线程模型 -- 协作式和抢占式。在协作式模型中，每个线程对于自己对CPU的控制权要保留多久、什么时候放弃有最终意见。在这个模型中，因为可能存在某个无赖线程占住控制权不放，所以其他线程可能永远无法得到运行。在抢占式模型中，操作系统本身采用基于时钟“滴答”的计时器，基于这个计时器，操作系统可以强制把控制权从一个线程转移到另一个线程，在这种情况下，决定哪个线程会得到下一次控制权的调度策略就有可能基于各种指标，例如相对优先级、某个线程已经等待执行的时间长短，等等。如果出于某些原因，出于running状态的线程需要等候某个资源(例如等候设备的输入数据到达，或者等候某些条件已经设定的通知)，或者在试图获得互斥体的时候被阻塞，因此线程决定睡眠，那么这时它可以进入blocked状态。当睡眠周期到期、预期输入到达，或者互斥体当前的拥有者将其释放并通知等候线程可以再次夺取互斥体时，阻塞的线程重新进入runnable状态。当线程的run()方法完成时(或者正常返回，或者抛出RuntimeException这样的未检测到异常)，线程将终止。这时，线程的状态是dead。当线程死亡时，就不能通过再次调用它的start()方法来重新启动它，如果那么做，则会抛出InvalidThreadStateException异常。</code></pre><h5 id="四种常见缺陷"><a href="#四种常见缺陷" class="headerlink" title="四种常见缺陷"></a>四种常见缺陷</h5><blockquote><p>争用条件</p></blockquote><pre><code>争用条件存在于这样的系统中：多个线程之间存在对共享资源的竞争，而胜出者决定系统的行为。在冲突的访问请求之间进行不正确的同步的另一个更可怕的后果是数据崩溃，此时，共享的数据结构有一部分有一个线程更新，而另一部分由另一个线程更新。在这种情况下，系统的行为不是按照胜出线程的意图进行，系统根部不按照任何一个线程的意图行动，所以两个线程最后都将以失败告终。</code></pre><blockquote><p>死锁</p></blockquote><pre><code>死锁的情况是指：线程由于等候某种条件变成真(如资源可以使用)，但是它等候的条件无法变成真，因为能够让条件变成真的线程在等候第一个线程“做某件事”。这样两个线程都在等候对方先采取第一步，所以都无法做事。</code></pre><blockquote><p>活动锁</p></blockquote><pre><code>活动锁与死锁不同，它是在线程实际工作的时候发生的，但这时还没有完成工作。这通常是在两个线程交叉工作的时候发生，所以第一个线程做的工作被另一个线程取消。一个简单的示例就是：每个线程已经拥有了一个对象，同时需要另外一个线程拥有的另外一个对象，每个线程放下自己拥有的对象，捡起另外一个线程放下的对象。显然，这两个线程会永远都运行在上锁这一步操作上，结果是什么都做不成。</code></pre><blockquote><p>资源耗尽</p></blockquote><pre><code>资源耗尽又称为“线程耗尽”，是java语言的wait/notify原语无法保证live-ness的后果。java强制这些方法要拥有它们等候或通知的对象锁。在某个线程上调用的wait方法再开始之前必须释放监视器锁，然后在从方法返回并获得通知之后，必须再次重新获得锁。因此java语言规范在锁本身之外，还描述了一套与每个对象相关的等候集。一旦线程释放了对象上的锁，线程就会放在这个等候集上。多数JVM实现把等候线程放在队列中。所以，如果在通知发生的时候，还有其他线程在等候监视器，那么就会把一个新线程放在队列尾部，而它并不是下一个获得锁的线程。所以等到被通知的线程实际得到监视器的时候，通知该线程的条件可能已经不再为真，所以它不得不再次wait。这种情况可能无限持续下去，从而造成运算工作的浪费(因为要反复把该线程放入等候集和从中取出)和线程耗尽。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;并发编程提供了不论是在单一操作系统上还是分布在大量系统上的操作的同时执行。这类操作实际上是一些指令顺序，例如单独某个顶级任务的子任务，这类操作能够并行执行，或者作为线程，或者作为进程。线程和进程之间的本质区别在于：进程通常是独立的(例如有独立的地址空间)，所
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap的高并发机制</title>
    <link href="http://yoursite.com/2019/06/28/ConcurrentHashMap_01/"/>
    <id>http://yoursite.com/2019/06/28/ConcurrentHashMap_01/</id>
    <published>2019-06-28T11:24:18.873Z</published>
    <updated>2019-07-02T02:34:13.257Z</updated>
    
    <content type="html"><![CDATA[<pre><code>ConcurrentHashMap是建立在Java内存模型基础上的。</code></pre><h5 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h5><pre><code>java的内存模型由一些规则组成，这些规则明确线程对内存的访问如何排序以及何时它们对线程是可见的。</code></pre><blockquote><p>重排序</p></blockquote><pre><code>内存模型描述了程序的可能行为。具体的编译器实现可以产生任意它喜欢的代码，只要所有执行这些代码产生的结果能够和内存模型预测的结果保持一致即可。这为编译器的实现者提供了很大的自由，包括操作的重排序。编译器生成指令的次序可以不同于源代码的版本。重排序后的指令，对于优化执行以及成熟的全局寄存器分配算法的使用都是有益的，它使得程序在计算性能上有了很大的提升。重排序类型包括：</code></pre><ol><li>编译器生成指令的次序，可以不同于源代码的版本</li><li>处理器可以乱序或者并行的执行指令</li><li>缓存会改变写入提交到主内存的变量的次序</li></ol><blockquote><p>内存可见性</p></blockquote><pre><code>由于现代可共享内存的多处理器架构可能导致一个线程无法马上(甚至永远)看到另一个线程操作产生的结果。所以java内存模型规定了JVM的一种最小保证：什么时候写入一个变量对其他线程可见。在现代可共享内存的多处理器体系结构中每个处理器都有自己的缓存，并周期性的与主内存协调一致。假设线程A写入一个变量值V，随后另一个线程B读取变量V的值，在下列情况下，线程B读取的值可能不是线程A写入的最新值：</code></pre><ol><li>执行线程A的处理器把变量V缓存到寄存器中</li><li>执行线程A的处理器把变量V缓存到自己的缓存中，但是还没有同步刷新到主内存中去</li><li>执行线程B的处理器缓存中有变量V的旧值</li></ol><blockquote><p>Happends-before关系</p></blockquote><pre><code>happens-before关系保证：如果线程A和线程B满足happens-before关系，则线程A执行动作的结果对于线程B是可见的。如果两个操作未按照happens-before排序，JVM将可以对它们任意重排序。部分happens-before关系法则(与ConcurrentHashMap有关的):</code></pre><ol><li>程序次序法则：如果在程序中，所有动作A出现在动作B之前，则线程中的每动作A都happens-before与该线程中的每一个动作B</li><li>监视器锁法则：对一个监视器的解锁happens-before于每个后续对同一监视器的加锁</li><li>Volatile变量法则：对Volatile域的写入操作happens-before于每个后续对同一Volatile的读操作</li><li>传递性：如果A happens-before于B，且Bhappens-before于C，则Ahappens-before于C</li></ol><h5 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h5><pre><code>ConcurrentHashMap类中包含两个静态内部类：HashEntry和Segment。HashEntry用来封装映射表的键/值对；Segment用来充当锁的角色。每个Segment对象守护这个散列映射表的若干个桶。每个桶是由若干个HashEntry对象链接起来的链表。一个ConcurrentHashMap实例中包含有若干个Segment对象组成的数组。</code></pre><blockquote><p>HashEntry</p></blockquote><blockquote><p>Segment</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;ConcurrentHashMap是建立在Java内存模型基础上的。&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;Java内存模型&quot;&gt;&lt;a href=&quot;#Java内存模型&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型&quot;&gt;&lt;/a&gt;Java
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ThreadLock</title>
    <link href="http://yoursite.com/2019/06/20/threadlocal_01/"/>
    <id>http://yoursite.com/2019/06/20/threadlocal_01/</id>
    <published>2019-06-20T10:07:49.937Z</published>
    <updated>2019-07-02T02:34:13.551Z</updated>
    
    <content type="html"><![CDATA[<pre><code>ThreadLocal是一个本地线程副本变量工具类。对于ThreadLocal，该类提供了线程局部变量。这些变量不同于他们的普通对应物，因为访问某个变量的每个线程都有自己的局部变量，他们独立于变量的初始副本。ThreadLocal实例通常是类中的private static字段，它们希望将状态与某一个线程相关联。</code></pre><ol><li>ThreadLocal提供了一种访问某个变量的特殊方式：访问到的变量属于当前线程，即保证每个变量不一样，而同一个线程在任何地方拿到的变量都是一致的</li><li>如果要使用ThreadLocal，通常定义为private static类型。</li></ol><p><strong><em>ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()实现的，而是通过每个线程中的new对象操作来创建对象的，每个线程创建一个，不是什么对象的拷贝或者是副本。</em></strong></p><pre><code>因此，如果ThreadLocal.set()存放的东西就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，即还是会存在并发访问问题。</code></pre><blockquote><p>ThreadLocal如何工作</p></blockquote><ul><li>Thread类中有一个成员变量叫做ThreadLocalMap，它是一个Map，它的Key是ThreadLocal类；</li><li>每个线程拥有自己的声明为ThreadLocal类型的变量；</li><li>此变量声明周期是由该线程决定的，开始于第一次初始；</li><li>由ThreadLocal的工作原理决定：每个线程独自拥有一个变量，并非共享或者拷贝</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;ThreadLocal是一个本地线程副本变量工具类。

对于ThreadLocal，该类提供了线程局部变量。这些变量不同于他们的普通对应物，因为访问某个变量的每个线程都有自己的局部变量，他们独立于变量的初始副本。ThreadLocal实例通常是类中的priv
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JWT - Json Web Token</title>
    <link href="http://yoursite.com/2019/06/20/jwt_01/"/>
    <id>http://yoursite.com/2019/06/20/jwt_01/</id>
    <published>2019-06-20T10:07:49.723Z</published>
    <updated>2019-07-02T02:34:13.481Z</updated>
    
    <content type="html"><![CDATA[<h4 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h4><blockquote><p>认证： Authentication</p></blockquote><pre><code>认证是为了验证目标对象的身份，主要是解决&quot;你是谁&quot;</code></pre><blockquote><p>授权： Authorization</p></blockquote><pre><code>授权是为了赋予目标对象的可操作资源，主要是解决&quot;你能干什么&quot;对于一般的WEB应用来说，通常使用HTTP来进行访问，而HTTP是无状态的，因此客户端和服务端需要增加处理将无状态会话变为有状态会话。SESSION机制解决了HTTP的会话状态问题。客户端向服务端发起请求，服务端为客户端生成唯一的session_id，并将该id存储在服务端，然后将该id返回给客户端，客户端将其存储在COOKIE中。当客户端再次向服务端发起请求时会携带session_id一同发往服务端，服务端通过判断session_id是否存在来判断客户端是否处于登录状态。</code></pre><h4 id="什么是Token"><a href="#什么是Token" class="headerlink" title="什么是Token"></a>什么是Token</h4><pre><code>在WEB应用中，Token是指访问资源的凭据。</code></pre><h4 id="什么是OAuth-2-0"><a href="#什么是OAuth-2-0" class="headerlink" title="什么是OAuth 2.0"></a>什么是OAuth 2.0</h4><ol><li>客户端访问资源服务器(SP),SP告诉客户端需要进行认证，将用户重定向至认证服务(IdP)；</li><li>IdP询问客户端SP是否可以访问客户端信息，如果客户端同意，IdP向客户端返回access code；</li><li>客户端拿access code向Idp换取access token，并携带access token向SP请求资源，SP接受请求后使用该access token向IdP验证该用户身份，验证成功则返回资源给客户端</li></ol><p><strong><em>OAuth的本意是一个应用允许另一个应用在用户授权的情况下访问自己的数据，因此其设计本意更倾向于授权而非认证。</em></strong></p><h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><pre><code>JWT即Json Web Token，由三部分组成： header，payload，signature</code></pre><ul><li><p>header ： 用于描述元信息，例如产生signature的算法</p></li><li><p>payload ： 用于携带所需要传递的用户信息，既可以添加官方字段也可以添加自定义字段</p></li><li><p>signature ： 签名信息</p><p>  理论来说，JWT机制可以取代SESSION机制，客户端向认证服务获取一份JWT并保存在客户端本地，每次请求服务端资源时都携带该合法的JWT，<br>  后端使用JWT做一次合法性的验证，这样也达到了间接认证的目的。</p></li></ul><p><strong><em>JWT的目的不是为了隐藏或者保护数据，而是为了确保数据确实来自被授权的客户端创建的(不被篡改)。</em></strong></p><pre><code>当我们获取到JWT的时候，由于header和payload只是经过了base64的编码，其编码的目的是为了便于数据结构的传输。signature的创建过是对数据体的签名行为，其目的是为了保证数据的完整性，实际上并没有加密任何数据。</code></pre><h4 id="JWT在WEB应用中的缺陷"><a href="#JWT在WEB应用中的缺陷" class="headerlink" title="JWT在WEB应用中的缺陷"></a>JWT在WEB应用中的缺陷</h4><ol><li><p>无法满足注销场景</p><p> 传统的session + cookie的方案中客户端注销时，服务端清空session即可，因为状态保存在服务端。而JWT是无状态的，服务端通过计算来<br> 校验有效性，即使客户端删除JWT，但是该JWT还是在有效期内，只不过处于游离状态</p></li><li><p>无法满足修改密码场景</p><p> 在修改密码之后，而原有JWT在有效期内仍可继续访问资源服务，此时只有强制修改签名所使用的秘钥才可以禁止原JWT的访问</p></li><li><p>无法满足token续签场景</p><p> 传统的COOKIE续签方案，SESSION的有限期是30分钟，30分钟内如果有访问，SESSION有效期会被刷新30分钟。在JWT的payload中也有一个exp<br> 过期时间参数，来代表一个JWT的时效性，但是payload本身是参与签名的，一旦过期时间被修改，整个JWT串就变了，因此JWT不支持续签。</p></li></ol><p><strong><em>在WEB应用中，绝大多数情况下，传统的cookie-session机制能够更好的处理认证和授权的问题。JWT适合做简单的RESTFUL API认证，颁发一个固定有效期的JWT，降低JWT暴露的风险，不应使用JWT做服务端的状态管理，这样才能使其发挥无状态的优势。</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;认证和授权&quot;&gt;&lt;a href=&quot;#认证和授权&quot; class=&quot;headerlink&quot; title=&quot;认证和授权&quot;&gt;&lt;/a&gt;认证和授权&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;认证： Authentication&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收器</title>
    <link href="http://yoursite.com/2019/06/20/jvm_05/"/>
    <id>http://yoursite.com/2019/06/20/jvm_05/</id>
    <published>2019-06-20T10:07:49.699Z</published>
    <updated>2019-07-02T02:34:13.474Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>垃圾回收器</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;垃圾回收器&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM 垃圾回收算法</title>
    <link href="http://yoursite.com/2019/06/20/jvm_04/"/>
    <id>http://yoursite.com/2019/06/20/jvm_04/</id>
    <published>2019-06-20T10:07:49.693Z</published>
    <updated>2019-07-02T02:34:13.468Z</updated>
    
    <content type="html"><![CDATA[<pre><code>在java内存区域中，PC计数器，虚拟机栈，本地方法栈三个区域随线程而生，随线程而亡；栈中的栈帧随着方法的进入和退出执行出栈和入栈操作，每个栈帧中分配多少内存基本在类结构确定下来的的时候就是已知的，因此这几个区域的内存分配和回收都具备确定性，因为方法结束或线程结束时，内存自然就跟随者回收了。而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序运行期间才能知道会创建哪些对象，因此这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</code></pre><blockquote><p>对象生死的判定</p></blockquote><pre><code>垃圾回收器做的第一件事就是判断一个对象应该是生存或消亡。</code></pre><ol><li><p>引用计数算法</p><p> java堆中每个具体对象都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1，每当有一个地方引用它时，计数器值就+1，当引用失效时，即一个对象的某个引用超过了生命周期(出作用域后)或者被设置为一个新值时，计数器值就-1。任何计数器值为0的对象可以被<br> 当做垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数-1。</p></li></ol><ul><li>优点： 引用计数收集器执行简单，判定效率高，交织在程序运行中，对程序不被长时间打断的实时环境比较有利。</li><li>缺点： 难以检测出对象的循环引用。同时，引用计数器增加了程序执行的开销。</li><li><strong>java没有选择这种算法进行垃圾回收。*</strong></li></ul><ol start="2"><li><p>可达性分析算法</p><p> 可达性分析算法也叫根搜索算法，通过一系列称为GC Roots的对象作为起点，然后向下搜索。搜索所走的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，即该对象不可达，也就表明该对象是不可用的。</p><p> 在java中，可作为GC Roots的对象有一下四种：</p></li><li><p>虚拟机栈(栈帧中的本地变量表)中引用的对象</p></li><li><p>本地方法栈中JNI(Native方法)引用的变量</p></li><li><p>方法区中类静态属性引用的变量</p></li><li><p>方法区中常量引用的变量</p></li></ol><blockquote><p> 对象引用分类</p></blockquote><ol><li>强引用 Strong Reference</li><li>软引用 Soft Reference</li><li>弱引用 Weak Reference</li><li>虚引用 Phantom Reference</li></ol><blockquote><p>finalize() 二次标记</p></blockquote><pre><code>一个对象是否应该在垃圾回收器的GC时回收，至少要经历两次标记过程。</code></pre><ul><li><p>第一次标记过程</p><p>  通过可达性分析算法分析对象是否与GC Roots可达。经过第一次标记，并且被筛选为不可达的对象会进行第二次标记。</p></li><li><p>第二次标记过程</p><p>  判断不可达对象是否有必要执行finalize方法。执行条件是当前对象的finalize方法被重写，并且还未被系统调用过。如果允许执行那么这个对象将会被放到一个叫F-Query的队列中，等待被执行。</p><p>  由于finalize由一个优先级比较低的Finalizer线程运行，所以该对象的finalize方法不一定被执行，即使被执行了，也不保证finalize方法一定会执行完。所以对象第二次小规模标记，即finalize方法中拯救自己，只需要重新和引用链上的任一对象建立关联即可。</p></li></ul><blockquote><p>垃圾回收算法</p></blockquote><ol><li><p>标记-清除算法</p><p> 标记-清除算法对根集合进行扫描，对存活的对象进行标记，标记完成后，在对整个空间内未被标记的对象扫描，进行回收</p><ol><li>标记阶段：通过根节点，标记所有从根节点开始的可达对象，未标记的对象就是未被引用的垃圾对象</li><li>清除阶段：清除所有未被标记的对象</li></ol><ul><li>优点： 实现简单，不需要对对象进行移动</li><li>缺点： 标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率</li></ul></li><li><p>复制算法</p><p> 解决了标记-清除算法中存在的效率问题，它将内存区域划分为相同的两个内存块。每次仅使用一半的空间，JVM生成的新对象放在另一半空间中，当一般空间用完时进行GC，把可达对象复制到另一半空间，然后把使用过的内存空间一次清理掉。</p><ul><li>优点： 按顺序分配内存即可，实现简单，运行高效，不用考虑内存碎片</li><li>缺点： 可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制</li></ul></li><li><p>标记-整理算法</p><p>标记-整理算法采用和标记-清除算法一样的方式进行对象的标记，但后续不直接对可回收对象进行清理，而是将所有的存活对象往一端空闲空间移动，然后清理掉端边界以外的内存空间</p><ul><li>优点： 解决了标记-清理算法的内存碎片问题</li><li>缺点： 仍需要进行局部对象移动，一定程度上降低了效率</li></ul></li><li><p>分带收集算法</p><p> 分代收集就是根据对象的存活周期将内存划分为几块。一般分为年轻代，老年代和永久代。</p><ol><li><p>新生代</p><p> 绝大多数最新被创建的对象会被分配到这里，由于大部分对象在创建后会很快变得不可达，所以很多对象被创建在新生代，然后消失。对象从这个区域消失的过程称之为minor GC</p><p> 新生代中存在一个Eden区和两个Survivor区。新对象会首先被分配在Eden区(如果新对象过大，会直接分配在老年代中)。在GC中，Eden区的<br> 对象会被移动到Survivor区中，直到对象满足一定的年龄(定义为熬过GC的次数)，会被移动到老年代</p><p> 可以设置新生代和老年代的相对大小。</p><ul><li>优点： 新生代大小会随着整个堆大小动态扩展。参数-XX:NewRatio设置老年代和新生代的比例。例如-XX:NewRatio=8指定老年代/新生代为8/1。老年代占堆大小的7/8，新生代占1/8。</li></ul></li><li><p>老年代</p><p> 对象没有变得不可达，并且从新生代中存活下来，会被拷贝到这里。其所占用的空间要比新生代多。由于其相对较大的空间，发生在老年代上的GC要比新生代少的多。对象从老年代中消失的过程称之为major GC(或者full GC)。</p></li><li><p>永久代</p><p> 类的层级信息，方法数据和方法信息(如字节码，栈和变量大小)，运行时常量池(jdk7之后移除永久代)，已确定的符号引用和虚方法表等等<br> 它们几乎都是静态的并且很少被卸载和回收，在jdk8之前的HotSpot虚拟机中，类的这些永久数据存放在一个叫做永久代的区域。</p><p> 永久代是一段连续的内存空间，我们在JVM启动之前可以通过设置-XX:MaxPermSize的值来控制永久代的大小。但是jdk8以后取消了永久代，这些元数据被移到了一个与堆不相连的元空间(Metaspace)的本地内存区域。</p></li></ol></li></ol><p><strong><em>jdk8堆内存一般是划分为年轻代和老年代，不同的年代根据自身的特性采用不同的垃圾收集算法。对于新生代，每次GC时都有大量的对象死亡，只有少量的对象存活。考虑到复制成本，适合采用复制算法，因此有了From Survivor和To Survivor区域。对于老年代，因为对象存活率高，没有额外的内存空间对它进行担保，因此适合采用标记-清理算法和标记-整理算法进行回收。</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;在java内存区域中，PC计数器，虚拟机栈，本地方法栈三个区域随线程而生，随线程而亡；栈中的栈帧随着方法的进入和退出执行出栈和入栈操作，每个栈帧中分配多少内存基本在类结构确定下来的的时候就是已知的，因此这几个区域的内存分配和回收都具备确定性，因为方法结束或线
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM 对象</title>
    <link href="http://yoursite.com/2019/06/20/jvm_03/"/>
    <id>http://yoursite.com/2019/06/20/jvm_03/</id>
    <published>2019-06-20T10:07:49.683Z</published>
    <updated>2019-07-02T02:34:13.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对象的创建方式</p></blockquote><h6 id="java中提供了一下创建对象的方式："><a href="#java中提供了一下创建对象的方式：" class="headerlink" title="java中提供了一下创建对象的方式："></a>java中提供了一下创建对象的方式：</h6><ol><li><p>使用new关键字</p></li><li><p>使用Class的newInstance方法</p></li><li><p>使用Constructor类的newInstance方法</p></li><li><p>使用clone方法 (需要实现Cloneable接口并实现clone方法)</p></li><li><p>使用反序列化 (需要实现Serializable接口)</p><p> 以new关键字为例，JVM堆中对象创建实例如下：<br> 当JVM遇到一条new指令时，首先会检查这个指令参数能否在常量池中定位一个符号引用，然后检查这个符号引用的类字节码对象是否加载，解析和初始化了，如果没有则执行对应的加载过程。</p></li></ol><ul><li>类加载完成后，JVM会为新生对象分配内存区域，对象所需内存空间大小在类加载完成后就已经确定</li><li>内存分配完成以后，JVM将分配到的内存空间都初始化为零值</li><li>虚拟机对对象进行一系列的设置，如所属类的元信息，对象的哈希码，对象GC分带年龄，线程持有的锁，偏向线程的id等信息，这些信息存储在对象头中</li></ul><blockquote><p>对象的布局</p></blockquote><pre><code>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</code></pre><h6 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h6><pre><code>HotSpot虚拟机中，对象头有两部分信息组成：运行时数据和类型指针。</code></pre><ol><li><p>运行时数据</p><p> 运行时数据用于存储对象自身运行时数据，如哈希码，GC分带年龄，线程持有的锁，偏向线程id等信息，这部分数据的长度在32位和64位的虚拟机中分别为32个bit和64个bit，官方称它为Mark Word。</p></li><li><p>类型指针</p><p> 指向实例对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个java数组，那么在对象头中还必须有一块用与记录数组长度的数据。</p></li></ol><h6 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h6><pre><code>实例数据部分是对象真正存储的有效信息，无论是从父类继承下来的还是该类自身的，都需要记录下来，而这部分的存储顺序受虚拟机的分配策略和定义的数据影响。默认分配策略是： long/double  --&gt;  int/float  --&gt;  short/char  --&gt;  byte/boolean  --&gt;  reference如果设置了-XX:FieldsAllocationStyle=0(默认为1)，那么引用类型数据就会优先分配存储空间：reference  --&gt;  long/double  --&gt;  int/float  --&gt;  short/char  --&gt;  byte/boolean</code></pre><p><strong><em>分配策略总是按照字节大小由大到小的顺序排列，相同大小的放在一起</em></strong></p><h6 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h6><pre><code>HotSpot虚拟机要求每个对象的起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍(32位为1倍，64位为两倍)，因此，当对象实例数据部分没有对齐的时候，就需要通过对齐填充来补全。</code></pre><blockquote><p>对象的访问定位</p></blockquote><pre><code>java程序需要通过JVM栈上的引用访问堆中的具体对象。对象的访问方式取决于JVM虚拟机的实现。目前主流的访问方式有句柄和直接指针两种方式。</code></pre><ol><li><p>句柄： 可以理解为指向指针的指针，维护者对象的指针。句柄不直接指向对象，而是指向对象的指针(句柄不发生变化，指向固定内存地址)，再由对象的指针指向对象的真实内存地址。</p><p> java堆中划分出一块内存来作为句柄池，引用中存储对象的举兵地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。<br> 引用中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而引用本身<br> 不需要修改。</p></li><li><p>指针： 指向对象，代表一个对象在内存中的起始地址。</p><p> 使用直接指针引用，引用中存储的直接就是对象地址，那么java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。<br> 使用直接指针引用访问速度更快，节省了一次指针定位的时间开销。由于对象的访问在java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对象的创建方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;java中提供了一下创建对象的方式：&quot;&gt;&lt;a href=&quot;#java中提供了一下创建对象的方式：&quot; class=&quot;headerlink&quot; title=&quot;java中提供了一下创建对象
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>定时任务</title>
    <link href="http://yoursite.com/2019/06/13/%E6%9D%82%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/06/13/杂记/</id>
    <published>2019-06-13T08:49:06.839Z</published>
    <updated>2019-07-02T02:34:13.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定时任务的原理"><a href="#定时任务的原理" class="headerlink" title="定时任务的原理"></a>定时任务的原理</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;定时任务的原理&quot;&gt;&lt;a href=&quot;#定时任务的原理&quot; class=&quot;headerlink&quot; title=&quot;定时任务的原理&quot;&gt;&lt;/a&gt;定时任务的原理&lt;/h4&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java反射和内省</title>
    <link href="http://yoursite.com/2019/06/13/%E5%85%B3%E4%BA%8Ejava%E7%9A%84%E5%8F%8D%E5%B0%84%E5%92%8C%E5%86%85%E7%9C%81/"/>
    <id>http://yoursite.com/2019/06/13/关于java的反射和内省/</id>
    <published>2019-06-13T08:49:06.835Z</published>
    <updated>2019-07-02T02:34:13.608Z</updated>
    
    <content type="html"><![CDATA[<p>在java中所有的对象不是引用类型就是基本类型。不管什么类型的对象，java虚拟机都会为之实例化一个java.lang.Class的不可变实例，（Class类的实例就是运行的java应用里的classes和interfaces），这个实例会提供方法来检测对象的成员（members）和类型（type）信息。Class也有能力创建新的classes和objects。最重要的是Class是所有反射的API的入口。</p><h4 id="获取Class的方式"><a href="#获取Class的方式" class="headerlink" title="获取Class的方式"></a>获取Class的方式</h4><h5 id="object-getClass"><a href="#object-getClass" class="headerlink" title="object.getClass()"></a>object.getClass()</h5><pre><code>该方式只对引用类型有效</code></pre><h5 id="Class-class"><a href="#Class-class" class="headerlink" title="Class.class"></a>Class.class</h5><pre><code>基础类型获得相应的Class</code></pre><h5 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h5><pre><code>如果知道一个类的完整路径，可以通过该静态方法来获得相应的Class，该方式不能用于基础类型</code></pre><h5 id="Object-TYPE"><a href="#Object-TYPE" class="headerlink" title="Object.TYPE"></a>Object.TYPE</h5><pre><code>基本类型可以通过其包装类型的TYPE属性来获取Class</code></pre><h5 id="Class-getClass"><a href="#Class-getClass" class="headerlink" title="Class.getClass()"></a>Class.getClass()</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在java中所有的对象不是引用类型就是基本类型。不管什么类型的对象，java虚拟机都会为之实例化一个java.lang.Class的不可变实例，（Class类的实例就是运行的java应用里的classes和interfaces），这个实例会提供方法来检测对象的成员（memb
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Doc</title>
    <link href="http://yoursite.com/2019/06/13/Spring%20Doc_01/"/>
    <id>http://yoursite.com/2019/06/13/Spring Doc_01/</id>
    <published>2019-06-13T08:49:06.825Z</published>
    <updated>2019-07-02T02:34:13.542Z</updated>
    
    <content type="html"><![CDATA[<p>依赖解决过程</p><ol><li>创建ApplicationContext并初始化配置文件源信息中所声明的bean对象，配置源文件可以是XML，java代码或者是注解。</li><li>对于每个bean，它的依赖通过表单属性，构造参数，静态工厂方法来表达，在bean被实际创建的时候需要提供这些依赖。</li><li>每一个属性或者构造参数是一个设置真实值的定义，或者是容器中其他的bean的引用。</li><li>每一个属性或者构造参数的值都会被转为属性或者是构造参数的实际类型值，默认情况下，spring能够根据spring默认支持的格式化方式来进行转化。</li></ol><h4 id="SpringEL"><a href="#SpringEL" class="headerlink" title="SpringEL"></a>SpringEL</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;依赖解决过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建ApplicationContext并初始化配置文件源信息中所声明的bean对象，配置源文件可以是XML，java代码或者是注解。&lt;/li&gt;
&lt;li&gt;对于每个bean，它的依赖通过表单属性，构造参数，静态工厂方法来表达，在bean
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ 配置</title>
    <link href="http://yoursite.com/2019/06/13/RabbitMQ_02/"/>
    <id>http://yoursite.com/2019/06/13/RabbitMQ_02/</id>
    <published>2019-06-13T08:49:06.821Z</published>
    <updated>2019-07-02T02:34:13.537Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ自带默认的构建配置。默认配置对于大部分环境来说是完全足够的。对于其他的一些场景来说，比如生产环境，通过类似插件的方式来配置<br>broker。</p><p>由于配置项的修改会影响系统(包括插件)的许多地方，因此配置文档会将会深入的介绍哪些配置是可以修改的<br>产品清单指出了在生产环境下可能会被修改的配置项概要。</p><blockquote><p>RabbitMQ提供了三种通用的服务端的配置方式</p></blockquote><h4 id="一-配置文件"><a href="#一-配置文件" class="headerlink" title="(一)配置文件"></a>(一)配置文件</h4><ol><li>TCP监听器和其他的网络相关配置</li><li>TLS</li><li>资源约束(预警)</li><li>后台认证和授权</li><li>消息的存储设置</li></ol><h4 id="二-环境变量"><a href="#二-环境变量" class="headerlink" title="(二)环境变量"></a>(二)环境变量</h4><p>节点名称的定义，文件和目录的位置，运行时的标识取自shell或者是环境配置文件中(Linux,MacOS,BSD系统下为rabbitmq-env.conf   windows下为rabbitmq-env-conf.bat)</p><h4 id="三-rabbitmqctl"><a href="#三-rabbitmqctl" class="headerlink" title="(三)rabbitmqctl"></a>(三)rabbitmqctl</h4><p>当使用内部的后台认证和授权时，rabbitmqctl是用于管理虚拟主机，用户和权限的工具</p><h4 id="四-rabbitmq-plugins"><a href="#四-rabbitmq-plugins" class="headerlink" title="(四)rabbitmq-plugins"></a>(四)rabbitmq-plugins</h4><p>rabbitmq-plugins是用于管理启用插件的工具</p><h4 id="五-运行时参数和策略"><a href="#五-运行时参数和策略" class="headerlink" title="(五)运行时参数和策略"></a>(五)运行时参数和策略</h4><p>定义了集群范围的配置，可以在运行时改变从而比较方便的配置像包含可选参数的队列组，交换机组等等。</p><h3 id="rabbitmq-conf中的核心服务变量配置"><a href="#rabbitmq-conf中的核心服务变量配置" class="headerlink" title="rabbitmq.conf中的核心服务变量配置"></a>rabbitmq.conf中的核心服务变量配置</h3><blockquote><p>listeners： 用于监听“plain” AMQP 0-9-1 和 AMQP 1.0的连接(不使用TLS)的主机名/端口</p></blockquote><blockquote><p>num_acceptors.tcp：Erlang进程能够处理TCP的连接数量</p></blockquote><blockquote><p>handshake_timeout：AMQP 0-9-1协议的握手最大时间(单位：毫秒)</p></blockquote><blockquote><p>listeners.ssl：用于监听AMQP 0-9-1 and AMQP 1.0的TLS连接</p></blockquote><blockquote><p>num_acceptors.ssl：Erlang进程能够处理的客户端的TLS连接数</p></blockquote><blockquote><p>ssl_options： TLS的配置项</p></blockquote><blockquote><p>ssl_handshake_timeout：TLS的握手超时时间(单位：毫秒)</p></blockquote><blockquote><p>vm_memory_high_watermark：触发流量控制的内存临界值，取决于操作系统的内存容量的绝对值或相对值</p></blockquote><blockquote><p>vm_memory_calculation_strategy：内存使用的报告策略。</p></blockquote><ol><li>allocated：使用Erlang内存分配器统计</li><li>rss：使用操作系统的RSS内存报告。</li><li>legacy：使用legacy内存报告。这种统计方式是相当不准确的</li><li>erlang：和legacy相似</li></ol><blockquote><p>vm_memory_high_watermark_paging_ratio：</p></blockquote><blockquote><p>total_memory_available_override_value</p></blockquote><blockquote><p>disk_free_limit：</p></blockquote><blockquote><p>log.file.level：</p></blockquote><blockquote><p>channel_max：</p></blockquote><blockquote><p>channel_operation_timeout：</p></blockquote><blockquote><p>heartbeat：</p></blockquote><blockquote><p>default_vhost：<br>default_user<br>default_pass<br>default_user_tags<br>default_permissions<br>loopback_users<br>cluster_formation.classic_config.nodes<br>collect_statistics</p></blockquote><blockquote><p>collect_statistics_interval</p></blockquote><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><pre><code>可选的队列参数，“x-arguments”，这些属性名称被定义在AMQP 0-9-1协议中。可以再client端队列声明时提供的map集合。在插件和特定的broker的特性中所使用。例如：</code></pre><ol><li>Message and Queue TTL 消息和队列的存活时间</li><li>Queue length limit 队列长度限制</li><li>Mirroring settings 镜像配置</li><li>Max number of priorities 优先级的最大数量</li><li>Consumer priorities 消费者的优先级  等等</li></ol><blockquote><p>可选参数可通过两种方式提供</p></blockquote><ol><li>为队列组使用策略(推荐)</li><li>在客户端声明一个队列时的基础信息中配置</li></ol><blockquote><p>临时队列，队列自动删除有三种方式：</p></blockquote><ol><li>Exclusive queues 独占队列</li><li>TTLs 存活时间</li><li>Auto-delete 自动删除</li></ol><p>如果一个队列没有任何消费者，例如，所有的消费行为均为“basic.get”方法，它是不会被自动删除的，这种情况下，需要使用独占队列或者设置队列存活时间。</p><blockquote><p>消息状态，队列消息可能处于一下两种状态</p></blockquote><ol><li>准备投递</li><li>已经被投递但是还没被消费者确认</li></ol><blockquote><p>决定队列的长度，队列长度的设定有很多中方法：</p></blockquote><ol><li>在AMQP 0-9-1协议中，使用queue.declare方法的一个属性设置来响应。属性的名字叫做“message_count”，如何接入取决于客户端库的差异</li></ol><p>队列的长度被定义为处于投递状态的消息数量</p><blockquote><p>RabbitMQ 支持一下几个协议:</p></blockquote><ol><li><p>AMQP 0-9-1 with extensions<br> AMQP 0-9-1 提供了一种在单一TCP连接上进行多路传输的连接方式。也就是说应用可以在单一TCP连接上开启多个叫做“通道”(channel)的轻量级连接。<br> AMPQ 0-9-1客户端在连接建立后开启一个或多个通道然后在通道上执行协议操作。<br> 在一条连接上可以同时建立的通道数量是由客户端和服务端在建立连接时协商决定的。客户端配置的通道最大数量不能超过服务端配置的通道最大数量。<br> AMQP 0-9-1 支持不同的认证机制。比较常用的是为应用提供一对X509认证的证书和PKI。</p></li><li><p>AMQP 1.0<br> AMQP 1.0 提供了一种在单一TCP连接上进行多路传输的连接方式。也就是说应用可以在单一TCP连接上开启多个叫做“会话”(session)的轻量级连接。应用可以建立一个或多个连接来发布或消费消息。</p></li><li><p>MQTT 3.1.1<br> MQTT 3.1也遵循下面所提的连接建立流程，MQTT支持可选身份认证，使用时RabbitMQ会提供预置的凭证。</p></li><li><p>STOMP 1.0 through 1.2<br> STOMP也遵循下面所提的连接建立流程。</p></li></ol><p>操作系统对单一进程能够同时开启的TCP连接数量有一个限定范围。这个限定的连接数量在开发环境下或者是QA环境下是足够的，但在生产环境必须要调高此限制来应对大量客户端的并发连接。</p><blockquote><p>Connection LifeCycle</p></blockquote><pre><code>为了客户端可以和RabbitMQ进行交互首先需要建立一条连接，这个过程包含以下几步：</code></pre><ol><li><p>应用对使用明确的连接后台的客户端库进行配置</p></li><li><p>客户端库把配置的主机地址解析为一个或多个ip地址</p></li><li><p>客户端库与目标主机地址和端口建立一个TCP连接</p></li><li><p>在服务端接收TPC连接后，执行具体的协议协商程序</p></li><li><p>接下来服务端会对客户端进行验证</p></li><li><p>现在客户端可以进行操作了，服务端会对每一个操作进行认证检查。</p><p> 这个流程不会因为协议不同而发生变化，但是会有一点细微的不同。</p></li></ol><blockquote><p>Connection Leaks</p></blockquote><pre><code>连接泄露是一种在应用重复的开启连接但是没有关闭连接或者是只关闭了其中的一部分的情况。</code></pre><blockquote><p>High Connection Churn</p></blockquote><pre><code>一个系统的新建连接的速率一直很高并且关闭连接的速率也一直很高时就说明该系统具有高连接丢失。这意味着该系统使用的是短连接。虽然对于系统的某些工作负载来说这是一个较为正常的状态，但还是尽可能的推荐使用长连接。</code></pre><blockquote><p>RabbitMQ 中的 Connection和Channel</p></blockquote><pre><code>无论是生产者还是消费者，都需要和RabbitMQ的broker建立连接，这个连接就是一条TCP连接，也就是Connection一旦TCP连接建立起来，客户端就可以创建一个AMQP信道(Channel)，每个信道都会被指派一个唯一的id。信道是建立在Connection之上的虚拟连接，RabbitMQ处理的每条AMQP指令都是通过信道完成的。原本使用Connection就能完成信道的工作，为什么要引入信道呢？一个应用程序中有很多线程需要从RabbitMQ中消费消息，或者生产消息，那必然需要建立很多个Connection，也就是多个TCP连接，而对于操作系统来说，建立和销毁TCP连接是非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。RabbitMQ采用了TCP连接复用，每个线程把持一个信道，所以信道复用了Connection的TCP连接，同时RabbitMQ可以确保每个线程的私密性，就像独立的连接一样，当每个信道的连接不是很大时，复用单一的Connection可以在产生性能瓶颈的情况下有效的节省TCP连接资源，但是信道本身流量很大时，这个时候多个信道复用一个Connection就会产生性能瓶颈，进而使整体的流量被限制了，此时就需要开辟多个Connection，将这些信道均摊到这些Connection中。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RabbitMQ自带默认的构建配置。默认配置对于大部分环境来说是完全足够的。对于其他的一些场景来说，比如生产环境，通过类似插件的方式来配置&lt;br&gt;broker。&lt;/p&gt;
&lt;p&gt;由于配置项的修改会影响系统(包括插件)的许多地方，因此配置文档会将会深入的介绍哪些配置是可以修改的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Rabbit MQ 使用记录(一)</title>
    <link href="http://yoursite.com/2019/06/13/RabbitMQ_01/"/>
    <id>http://yoursite.com/2019/06/13/RabbitMQ_01/</id>
    <published>2019-06-13T08:49:06.817Z</published>
    <updated>2019-07-02T02:34:13.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Rabbit-MQ-使用之broker"><a href="#Rabbit-MQ-使用之broker" class="headerlink" title="Rabbit MQ 使用之broker"></a>Rabbit MQ 使用之broker</h3><p>CachingConnectionFactory默认的缓存模式是CHANNEL，RabbitAdmin实现会在同一个ApplicationContext中自动延迟声明Queues，Exchanges和Bindings。只要Connection打开了与Broker的连接，这些组件就会被声明。</p><blockquote><p>延迟消息交换器</p></blockquote><blockquote><p>事物</p></blockquote><blockquote><p>消息监听器</p></blockquote><pre><code>acknowledge:应答模式</code></pre><ol><li><p>NONE:不发送应答</p></li><li><p>MANUAL:手动应答</p></li><li><p>AUTO:自动应答</p><p> concurrentConsumers:每个监听器上初始启动的并发消费者的数量</p><p> defaultRequeueRejected:因监听器抛出异常而遭受拒绝的消息是否需要重新入列。默认为true</p><p> missingQueuesFatal:</p></li></ol><blockquote><p>RabbitMQ相关概念：</p></blockquote><p>ConnectionFactory: 应用程序与Rabbit之间建立连接的管理器<br>Channel：消息推送使用的通道<br>Exchange：用于接收、分配消息<br>Queue：用于存储生产者的消息<br>RoutingKey：用于把生产者的数据分配到交换机上<br>BindingKey：用于把交换机的消息绑定到队列上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Rabbit-MQ-使用之broker&quot;&gt;&lt;a href=&quot;#Rabbit-MQ-使用之broker&quot; class=&quot;headerlink&quot; title=&quot;Rabbit MQ 使用之broker&quot;&gt;&lt;/a&gt;Rabbit MQ 使用之broker&lt;/h3&gt;&lt;p&gt;Ca
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Netty(一)</title>
    <link href="http://yoursite.com/2019/06/13/network_programming01/"/>
    <id>http://yoursite.com/2019/06/13/network_programming01/</id>
    <published>2019-06-13T08:49:06.812Z</published>
    <updated>2019-07-02T02:34:13.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="Bootstrap是什么"><a href="#Bootstrap是什么" class="headerlink" title="Bootstrap是什么"></a>Bootstrap是什么</h4></blockquote><p>ServerBootstrap 和 Bootstrap</p><blockquote><h4 id="数据的“入站”和“出站”"><a href="#数据的“入站”和“出站”" class="headerlink" title="数据的“入站”和“出站”"></a>数据的“入站”和“出站”</h4></blockquote><p>入站：数据从远程主机到用户应用程序称为“入站”<br>出站：数据从用户应用程序到远程主机称为“出站”</p><blockquote><h4 id="数据的“编码”和“解码”"><a href="#数据的“编码”和“解码”" class="headerlink" title="数据的“编码”和“解码”"></a>数据的“编码”和“解码”</h4></blockquote><p>在计算机的世界里从来都是只有0和1，若要使得计算机能够认识语言文字，就需要建立一种从从文字到0,1的映射。<br>从文字到0,1的映射称为“编码”<br>从0,1到文字的映射称为“解码”</p><blockquote><h5 id="计算机是如何显示文字的"><a href="#计算机是如何显示文字的" class="headerlink" title="计算机是如何显示文字的"></a>计算机是如何显示文字的</h5></blockquote><p>我们知道，计算式是以二进制的形式来保存和处理数据的，也就是说，不管我们使用键盘进行输入，还是让计算机去读取某一个文本文件，计算机得到的原始内容是一些二进制序列，当需要对这些二进制序列进行显示时，计算机会按照某种“翻译机制”(也就是编码方式)，取得这些二进制序列所表示的每个文字的“轮廓描述”(点阵或矢量图)，知道了轮廓，计算机便可以将二进制序列所表示的实际的文字形状显示在屏幕上了。</p><blockquote><h5 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h5></blockquote><p>将一些自然语言中的字符组成一个集合，并对集合中的每个字符制定规范化的编码方式，这个字符的集合和规范方式的编码方式就组成了一个字符集</p><blockquote><h5 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h5></blockquote><p>字符编码即建立一套自然语言中的“字符”跟计算机能够存储处理的二进制数的映射规则，即在一个字符集内，用一个特定的二进制数表示一个<br>唯一的“字符”。</p><blockquote><h5 id="为什么需要编码"><a href="#为什么需要编码" class="headerlink" title="为什么需要编码"></a>为什么需要编码</h5></blockquote><p>当数据不利于计算机处理、存储的时候，就需要对它进行编码。</p><ol><li>对字符进行编码是因为自然语言中的字符不利于计算机处理和存储</li><li>对图片信息、视频信息、声音信息进行压缩、优化，将其格式化，是为了保证媒体资源质量的同时，尽量的节省网络带宽和本地存储的空间</li><li>对URL进行编码是为了避免URL解析时发生歧义，简化解码方式</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;Bootstrap是什么&quot;&gt;&lt;a href=&quot;#Bootstrap是什么&quot; class=&quot;headerlink&quot; title=&quot;Bootstrap是什么&quot;&gt;&lt;/a&gt;Bootstrap是什么&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;Ser
      
    
    </summary>
    
    
  </entry>
  
</feed>
