<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Helianthus</title>
  <meta name="author" content="Helianthus W">

  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Helianthus">

  
  

  
    <meta property="og:image" content>
  

  
  <link href="/css/images/favicon.ico" rel="icon">
  

  <link rel="alternate" href="/atom.xml" title="Helianthus" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src="//push.zhanzhang.baidu.com/push.js"></script>

</head>
</html>

<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Helianthus</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-13T08:49:06.839Z"><a href="/2019/06/13/杂记/">2019-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/06/13/杂记/"></a></h1>
  

    </header>
    <div class="entry">
      
        <h4 id="定时任务的原理"><a href="#定时任务的原理" class="headerlink" title="定时任务的原理"></a>定时任务的原理</h4>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-13T08:49:06.835Z"><a href="/2019/06/13/关于java的反射和内省/">2019-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/06/13/关于java的反射和内省/">java反射和内省</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在java中所有的对象不是引用类型就是基本类型。不管什么类型的对象，java虚拟机都会为之实例化一个java.lang.Class的不可变实例，（Class类的实例就是运行的java应用里的classes和interfaces），这个实例会提供方法来检测对象的成员（members）和类型（type）信息。Class也有能力创建新的classes和objects。最重要的是Class是所有反射的API的入口。</p>
<h4 id="获取Class的方式"><a href="#获取Class的方式" class="headerlink" title="获取Class的方式"></a>获取Class的方式</h4><h5 id="object-getClass"><a href="#object-getClass" class="headerlink" title="object.getClass()"></a>object.getClass()</h5><pre><code>该方式只对引用类型有效
</code></pre><h5 id="Class-class"><a href="#Class-class" class="headerlink" title="Class.class"></a>Class.class</h5><pre><code>基础类型获得相应的Class
</code></pre><h5 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h5><pre><code>如果知道一个类的完整路径，可以通过该静态方法来获得相应的Class，该方式不能用于基础类型
</code></pre><h5 id="Object-TYPE"><a href="#Object-TYPE" class="headerlink" title="Object.TYPE"></a>Object.TYPE</h5><pre><code>基本类型可以通过其包装类型的TYPE属性来获取Class
</code></pre><h5 id="Class-getClass"><a href="#Class-getClass" class="headerlink" title="Class.getClass()"></a>Class.getClass()</h5>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-13T08:49:06.825Z"><a href="/2019/06/13/Spring Doc_01/">2019-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/06/13/Spring Doc_01/"></a></h1>
  

    </header>
    <div class="entry">
      
        <hr>
<h2 id="Spring-Doc"><a href="#Spring-Doc" class="headerlink" title="Spring Doc"></a>Spring Doc</h2><p>依赖解决过程</p>
<ol>
<li>创建ApplicationContext并初始化配置文件源信息中所声明的bean对象，配置源文件可以是XML，java代码或者是注解。</li>
<li>对于每个bean，它的依赖通过表单属性，构造参数，静态工厂方法来表达，在bean被实际创建的时候需要提供这些依赖。</li>
<li>每一个属性或者构造参数是一个设置真实值的定义，或者是容器中其他的bean的引用。</li>
<li>每一个属性或者构造参数的值都会被转为属性或者是构造参数的实际类型值，默认情况下，spring能够根据spring默认支持的格式化方式来进行转化。</li>
</ol>
<h4 id="SpringEL"><a href="#SpringEL" class="headerlink" title="SpringEL"></a>SpringEL</h4>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-13T08:49:06.821Z"><a href="/2019/06/13/RabbitMQ_02/">2019-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/06/13/RabbitMQ_02/">RabbitMQ 配置</a></h1>
  

    </header>
    <div class="entry">
      
        <p>RabbitMQ自带默认的构建配置。默认配置对于大部分环境来说是完全足够的。对于其他的一些场景来说，比如生产环境，通过类似插件的方式来配置<br>broker。</p>
<p>由于配置项的修改会影响系统(包括插件)的许多地方，因此配置文档会将会深入的介绍哪些配置是可以修改的<br>产品清单指出了在生产环境下可能会被修改的配置项概要。</p>
<blockquote>
<p>RabbitMQ提供了三种通用的服务端的配置方式</p>
</blockquote>
<h4 id="一-配置文件"><a href="#一-配置文件" class="headerlink" title="(一)配置文件"></a>(一)配置文件</h4><ol>
<li>TCP监听器和其他的网络相关配置</li>
<li>TLS</li>
<li>资源约束(预警)</li>
<li>后台认证和授权</li>
<li>消息的存储设置</li>
</ol>
<h4 id="二-环境变量"><a href="#二-环境变量" class="headerlink" title="(二)环境变量"></a>(二)环境变量</h4><p>节点名称的定义，文件和目录的位置，运行时的标识取自shell或者是环境配置文件中(Linux,MacOS,BSD系统下为rabbitmq-env.conf   windows下为rabbitmq-env-conf.bat)</p>
<h4 id="三-rabbitmqctl"><a href="#三-rabbitmqctl" class="headerlink" title="(三)rabbitmqctl"></a>(三)rabbitmqctl</h4><p>当使用内部的后台认证和授权时，rabbitmqctl是用于管理虚拟主机，用户和权限的工具</p>
<h4 id="四-rabbitmq-plugins"><a href="#四-rabbitmq-plugins" class="headerlink" title="(四)rabbitmq-plugins"></a>(四)rabbitmq-plugins</h4><p>rabbitmq-plugins是用于管理启用插件的工具</p>
<h4 id="五-运行时参数和策略"><a href="#五-运行时参数和策略" class="headerlink" title="(五)运行时参数和策略"></a>(五)运行时参数和策略</h4><p>定义了集群范围的配置，可以在运行时改变从而比较方便的配置像包含可选参数的队列组，交换机组等等。</p>
<h3 id="rabbitmq-conf中的核心服务变量配置"><a href="#rabbitmq-conf中的核心服务变量配置" class="headerlink" title="rabbitmq.conf中的核心服务变量配置"></a>rabbitmq.conf中的核心服务变量配置</h3><blockquote>
<p>listeners： 用于监听“plain” AMQP 0-9-1 和 AMQP 1.0的连接(不使用TLS)的主机名/端口</p>
</blockquote>
<blockquote>
<p>num_acceptors.tcp：Erlang进程能够处理TCP的连接数量</p>
</blockquote>
<blockquote>
<p>handshake_timeout：AMQP 0-9-1协议的握手最大时间(单位：毫秒)</p>
</blockquote>
<blockquote>
<p>listeners.ssl：用于监听AMQP 0-9-1 and AMQP 1.0的TLS连接</p>
</blockquote>
<blockquote>
<p>num_acceptors.ssl：Erlang进程能够处理的客户端的TLS连接数</p>
</blockquote>
<blockquote>
<p>ssl_options： TLS的配置项</p>
</blockquote>
<blockquote>
<p>ssl_handshake_timeout：TLS的握手超时时间(单位：毫秒)</p>
</blockquote>
<blockquote>
<p>vm_memory_high_watermark：触发流量控制的内存临界值，取决于操作系统的内存容量的绝对值或相对值</p>
</blockquote>
<blockquote>
<p>vm_memory_calculation_strategy：内存使用的报告策略。</p>
</blockquote>
<ol>
<li>allocated：使用Erlang内存分配器统计</li>
<li>rss：使用操作系统的RSS内存报告。</li>
<li>legacy：使用legacy内存报告。这种统计方式是相当不准确的</li>
<li>erlang：和legacy相似</li>
</ol>
<blockquote>
<p>vm_memory_high_watermark_paging_ratio：</p>
</blockquote>
<blockquote>
<p>total_memory_available_override_value</p>
</blockquote>
<blockquote>
<p>disk_free_limit：</p>
</blockquote>
<blockquote>
<p>log.file.level：</p>
</blockquote>
<blockquote>
<p>channel_max：</p>
</blockquote>
<blockquote>
<p>channel_operation_timeout：</p>
</blockquote>
<blockquote>
<p>heartbeat：</p>
</blockquote>
<blockquote>
<p>default_vhost：<br>default_user<br>default_pass<br>default_user_tags<br>default_permissions<br>loopback_users<br>cluster_formation.classic_config.nodes<br>collect_statistics</p>
</blockquote>
<blockquote>
<p>collect_statistics_interval</p>
</blockquote>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><pre><code>可选的队列参数，“x-arguments”，这些属性名称被定义在AMQP 0-9-1协议中。可以再client端队列声明时提供的map集合。在插件和特定的
broker的特性中所使用。例如：
</code></pre><ol>
<li>Message and Queue TTL 消息和队列的存活时间</li>
<li>Queue length limit 队列长度限制</li>
<li>Mirroring settings 镜像配置</li>
<li>Max number of priorities 优先级的最大数量</li>
<li>Consumer priorities 消费者的优先级  等等</li>
</ol>
<blockquote>
<p>可选参数可通过两种方式提供</p>
</blockquote>
<ol>
<li>为队列组使用策略(推荐)</li>
<li>在客户端声明一个队列时的基础信息中配置</li>
</ol>
<blockquote>
<p>临时队列，队列自动删除有三种方式：</p>
</blockquote>
<ol>
<li>Exclusive queues 独占队列</li>
<li>TTLs 存活时间</li>
<li>Auto-delete 自动删除</li>
</ol>
<p>如果一个队列没有任何消费者，例如，所有的消费行为均为“basic.get”方法，它是不会被自动删除的，这种情况下，需要使用独占队列或者设置队列存活时间。</p>
<blockquote>
<p>消息状态，队列消息可能处于一下两种状态</p>
</blockquote>
<ol>
<li>准备投递</li>
<li>已经被投递但是还没被消费者确认</li>
</ol>
<blockquote>
<p>决定队列的长度，队列长度的设定有很多中方法：</p>
</blockquote>
<ol>
<li>在AMQP 0-9-1协议中，使用queue.declare方法的一个属性设置来响应。属性的名字叫做“message_count”，如何接入取决于客户端库的差异</li>
</ol>
<p>队列的长度被定义为处于投递状态的消息数量</p>
<blockquote>
<p>RabbitMQ 支持一下几个协议:</p>
</blockquote>
<ol>
<li><p>AMQP 0-9-1 with extensions<br> AMQP 0-9-1 提供了一种在单一TCP连接上进行多路传输的连接方式。也就是说应用可以在单一TCP连接上开启多个叫做“通道”(channel)的轻量级连接。<br> AMPQ 0-9-1客户端在连接建立后开启一个或多个通道然后在通道上执行协议操作。<br> 在一条连接上可以同时建立的通道数量是由客户端和服务端在建立连接时协商决定的。客户端配置的通道最大数量不能超过服务端配置的通道最大数量。<br> AMQP 0-9-1 支持不同的认证机制。比较常用的是为应用提供一对X509认证的证书和PKI。</p>
</li>
<li><p>AMQP 1.0<br> AMQP 1.0 提供了一种在单一TCP连接上进行多路传输的连接方式。也就是说应用可以在单一TCP连接上开启多个叫做“会话”(session)的轻量级连接。应用可以建立一个或多个连接来发布或消费消息。</p>
</li>
<li><p>MQTT 3.1.1<br> MQTT 3.1也遵循下面所提的连接建立流程，MQTT支持可选身份认证，使用时RabbitMQ会提供预置的凭证。</p>
</li>
<li><p>STOMP 1.0 through 1.2<br> STOMP也遵循下面所提的连接建立流程。</p>
</li>
</ol>
<p>操作系统对单一进程能够同时开启的TCP连接数量有一个限定范围。这个限定的连接数量在开发环境下或者是QA环境下是足够的，但在生产环境必须要调高此限制来应对大量客户端的并发连接。</p>
<blockquote>
<p>Connection LifeCycle</p>
</blockquote>
<pre><code>为了客户端可以和RabbitMQ进行交互首先需要建立一条连接，这个过程包含以下几步：
</code></pre><ol>
<li>应用对使用明确的连接后台的客户端库进行配置</li>
<li>客户端库把配置的主机地址解析为一个或多个ip地址</li>
<li>客户端库与目标主机地址和端口建立一个TCP连接</li>
<li>在服务端接收TPC连接后，执行具体的协议协商程序</li>
<li>接下来服务端会对客户端进行验证</li>
<li><p>现在客户端可以进行操作了，服务端会对每一个操作进行认证检查。</p>
<p> 这个流程不会因为协议不同而发生变化，但是会有一点细微的不同。</p>
</li>
</ol>
<blockquote>
<p>Connection Leaks</p>
</blockquote>
<pre><code>连接泄露是一种在应用重复的开启连接但是没有关闭连接或者是只关闭了其中的一部分的情况。
</code></pre><blockquote>
<p>High Connection Churn</p>
</blockquote>
<pre><code>一个系统的新建连接的速率一直很高并且关闭连接的速率也一直很高时就说明该系统具有高连接丢失。这意味着该系统使用的是短连接。虽然对于系统的某些工作负载来说这是一个较为正常的状态，但还是尽可能的推荐使用长连接。
</code></pre><blockquote>
<p>RabbitMQ 中的 Connection和Channel</p>
</blockquote>
<pre><code>无论是生产者还是消费者，都需要和RabbitMQ的broker建立连接，这个连接就是一条TCP连接，也就是Connection
一旦TCP连接建立起来，客户端就可以创建一个AMQP信道(Channel)，每个信道都会被指派一个唯一的id。
信道是建立在Connection之上的虚拟连接，RabbitMQ处理的每条AMQP指令都是通过信道完成的。

原本使用Connection就能完成信道的工作，为什么要引入信道呢？

一个应用程序中有很多线程需要从RabbitMQ中消费消息，或者生产消息，那必然需要建立很多个Connection，也就是多个TCP连接，而对于操作系统来说，建立和销毁TCP连接是非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。

RabbitMQ采用了TCP连接复用，每个线程把持一个信道，所以信道复用了Connection的TCP连接，同时RabbitMQ可以确保每个线程的私密性，就像独立的连接一样，当每个信道的连接不是很大时，复用单一的Connection可以在产生性能瓶颈的情况下有效的节省TCP连接资源，但是信道本身流量很大时，这个时候多个信道复用一个Connection就会产生性能瓶颈，进而使整体的流量被限制了，此时就需要开辟多个Connection，将这些信道均摊到这些Connection中。
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-13T08:49:06.817Z"><a href="/2019/06/13/RabbitMQ_01/">2019-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/06/13/RabbitMQ_01/">Rabbit MQ 使用记录(一)</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Rabbit-MQ-使用之broker"><a href="#Rabbit-MQ-使用之broker" class="headerlink" title="Rabbit MQ 使用之broker"></a>Rabbit MQ 使用之broker</h3><p>CachingConnectionFactory默认的缓存模式是CHANNEL，RabbitAdmin实现会在同一个ApplicationContext中自动延迟声明Queues，Exchanges和Bindings。只要Connection打开了与Broker的连接，这些组件就会被声明。</p>
<blockquote>
<p>延迟消息交换器</p>
</blockquote>
<blockquote>
<p>事物</p>
</blockquote>
<blockquote>
<p>消息监听器</p>
</blockquote>
<pre><code>acknowledge:应答模式
</code></pre><ol>
<li>NONE:不发送应答</li>
<li>MANUAL:手动应答</li>
<li><p>AUTO:自动应答</p>
<p> concurrentConsumers:每个监听器上初始启动的并发消费者的数量</p>
<p> defaultRequeueRejected:因监听器抛出异常而遭受拒绝的消息是否需要重新入列。默认为true</p>
<p> missingQueuesFatal:</p>
</li>
</ol>
<blockquote>
<p>RabbitMQ相关概念：</p>
</blockquote>
<p>ConnectionFactory: 应用程序与Rabbit之间建立连接的管理器<br>Channel：消息推送使用的通道<br>Exchange：用于接收、分配消息<br>Queue：用于存储生产者的消息<br>RoutingKey：用于把生产者的数据分配到交换机上<br>BindingKey：用于把交换机的消息绑定到队列上</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-13T08:49:06.812Z"><a href="/2019/06/13/network_programming01/">2019-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/06/13/network_programming01/">Netty(一)</a></h1>
  

    </header>
    <div class="entry">
      
        <blockquote>
<h4 id="Bootstrap是什么"><a href="#Bootstrap是什么" class="headerlink" title="Bootstrap是什么"></a>Bootstrap是什么</h4></blockquote>
<p>ServerBootstrap 和 Bootstrap</p>
<blockquote>
<h4 id="数据的“入站”和“出站”"><a href="#数据的“入站”和“出站”" class="headerlink" title="数据的“入站”和“出站”"></a>数据的“入站”和“出站”</h4></blockquote>
<p>入站：数据从远程主机到用户应用程序称为“入站”<br>出站：数据从用户应用程序到远程主机称为“出站”</p>
<blockquote>
<h4 id="数据的“编码”和“解码”"><a href="#数据的“编码”和“解码”" class="headerlink" title="数据的“编码”和“解码”"></a>数据的“编码”和“解码”</h4></blockquote>
<p>在计算机的世界里从来都是只有0和1，若要使得计算机能够认识语言文字，就需要建立一种从从文字到0,1的映射。<br>从文字到0,1的映射称为“编码”<br>从0,1到文字的映射称为“解码”</p>
<blockquote>
<h5 id="计算机是如何显示文字的"><a href="#计算机是如何显示文字的" class="headerlink" title="计算机是如何显示文字的"></a>计算机是如何显示文字的</h5></blockquote>
<p>我们知道，计算式是以二进制的形式来保存和处理数据的，也就是说，不管我们使用键盘进行输入，还是让计算机去读取某一个文本文件，计算机得到的原始内容是一些二进制序列，当需要对这些二进制序列进行显示时，计算机会按照某种“翻译机制”(也就是编码方式)，取得这些二进制序列所表示的每个文字的“轮廓描述”(点阵或矢量图)，知道了轮廓，计算机便可以将二进制序列所表示的实际的文字形状显示在屏幕上了。</p>
<blockquote>
<h5 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h5></blockquote>
<p>将一些自然语言中的字符组成一个集合，并对集合中的每个字符制定规范化的编码方式，这个字符的集合和规范方式的编码方式就组成了一个字符集</p>
<blockquote>
<h5 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h5></blockquote>
<p>字符编码即建立一套自然语言中的“字符”跟计算机能够存储处理的二进制数的映射规则，即在一个字符集内，用一个特定的二进制数表示一个<br>唯一的“字符”。</p>
<blockquote>
<h5 id="为什么需要编码"><a href="#为什么需要编码" class="headerlink" title="为什么需要编码"></a>为什么需要编码</h5></blockquote>
<p>当数据不利于计算机处理、存储的时候，就需要对它进行编码。</p>
<ol>
<li>对字符进行编码是因为自然语言中的字符不利于计算机处理和存储</li>
<li>对图片信息、视频信息、声音信息进行压缩、优化，将其格式化，是为了保证媒体资源质量的同时，尽量的节省网络带宽和本地存储的空间</li>
<li>对URL进行编码是为了避免URL解析时发生歧义，简化解码方式</li>
</ol>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-13T08:49:06.810Z"><a href="/2019/06/13/markdown_gfm/">2019-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/06/13/markdown_gfm/"></a></h1>
  

    </header>
    <div class="entry">
      
        
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-13T08:49:06.807Z"><a href="/2019/06/13/markdown_01/">2019-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/06/13/markdown_01/">first blog</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="第一篇Markdown"><a href="#第一篇Markdown" class="headerlink" title="第一篇Markdown"></a>第一篇Markdown</h2><h3 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h3><h4 id="引用用法："><a href="#引用用法：" class="headerlink" title="引用用法："></a>引用用法：</h4><blockquote>
<p>采菊东篱下，悠然见南山</p>
</blockquote>
<h4 id="中划线用法"><a href="#中划线用法" class="headerlink" title="中划线用法"></a>中划线用法</h4><p><del>尽力而位这个成语中存在错别字，应该是尽力而为</del></p>
<h4 id="斜体用法"><a href="#斜体用法" class="headerlink" title="斜体用法"></a>斜体用法</h4><p>我正在学习JavaScript用法<br>我正在学习<em>JavaScript</em>用法</p>
<h4 id="粗体用法"><a href="#粗体用法" class="headerlink" title="粗体用法"></a>粗体用法</h4><p>正常：我喜欢在Mac上写作，因为Mac很优美<br>加粗：我喜欢在<strong>Mac</strong>上写作，因为<strong>Mac</strong>很优美</p>
<h4 id="斜粗体使用"><a href="#斜粗体使用" class="headerlink" title="斜粗体使用"></a>斜粗体使用</h4><p>正常：我喜欢在<strong><em>Mac</em></strong>上写作，因为<strong><em>Mac</em></strong>很优美</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://helianthus-w.github.io" target="_blank" rel="noopener">helianthus-w</a></p>
<h4 id="图片-可使用本地地址和远程地址"><a href="#图片-可使用本地地址和远程地址" class="headerlink" title="图片(可使用本地地址和远程地址)"></a>图片(可使用本地地址和远程地址)</h4><p><img src="C:\Users\111\Pictures\download_main_page_-_big_photo.jpg" alt="头像"></p>
<h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>在列表前加上一个*、+、-即可，文字与符号之间最好空一格</p>
<ul>
<li>首先，我们应该</li>
<li>其次，我们应当</li>
</ul>
<ul>
<li>白日依山尽</li>
<li>黄河入海流</li>
<li>欲穷千里目</li>
<li>更上一层楼</li>
</ul>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>添加有序列表的方法是，在文字前添加数字加英文句点，文字与符号之间最好空一格</p>
<ol>
<li>《平凡的世界》</li>
<li>《活着》</li>
</ol>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>给文字添加背景 只需要在文字的两边添加反引号`即可</p>
<p>我很喜欢苹果的新编程语言<code>swift</code></p>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>:—- 左对齐 :—-: 居中  —-:右对齐</p>
<table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:left">张三</th>
<th style="text-align:center">李四</th>
<th style="text-align:right">王五</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">性别</td>
<td style="text-align:left">男</td>
<td style="text-align:center">男</td>
<td style="text-align:right">男</td>
</tr>
<tr>
<td style="text-align:left">身高</td>
<td style="text-align:left">170</td>
<td style="text-align:center">180</td>
<td style="text-align:right">190</td>
</tr>
<tr>
<td style="text-align:left">地址</td>
<td style="text-align:left">北京</td>
<td style="text-align:center">上海</td>
<td style="text-align:right">深圳</td>
</tr>
</tbody>
</table>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>在需要添加代码的上下两行添加三个反引号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-13T08:49:06.803Z"><a href="/2019/06/13/log_01/">2019-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/06/13/log_01/"></a></h1>
  

    </header>
    <div class="entry">
      
        <p>日志等级：<br>ERROR：系统产生的错误信息，往往会严重影响系统的稳定性<br>WARNING: 警告信息，这类信息需要特别注意但是不会影响系统运行<br>INFO: 系统内部状态，可以用来分析一些工作<br>DEBUG: 调试信息，这类日志一般会在开发的时候用的较多<br>TRACE: 流程追踪信息，这类信息一般用来追踪一个操作流</p>
<p>ERROR &gt; WARNING &gt; INFO &gt; DEBUG&gt; TRACE</p>
<p>对于后端系统日志而言，应用一直在后台没日没夜的运行，我们不能在系统出现问题的时候再去添加新的埋点（打印日志的地方），所以需要仔细的考量需要埋点的地方，其次后端系统由于业务场景不同，往往产生大量的日志，这就需要对日志进行分类一边后续的分析。由于后端系统会长时间运行，所以日志会不断的产生，为了存储大量的日志信息，还需要合适的策略来对日志进行文件存储。</p>
<p>从业务角度，可以把日志分为以下几类：<br>1.业务日志 比如用户的操作日志，主要用来监控业务逻辑的执行情况<br>2.错误日志 系统错误信息<br>3.摘要日志 系统操作上下文的摘要信息<br>4.统计日志 可以汇总的统计的信息</p>
<p>ELK</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-06-13T08:49:06.798Z"><a href="/2019/06/13/jvm_02/">2019-06-13</a></time>
      
      
  
    <h1 class="title"><a href="/2019/06/13/jvm_02/">JVM内存区</a></h1>
  

    </header>
    <div class="entry">
      
        <h4 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h4><pre><code>JVM在执行Java程序的过程中，会把所管理的内存划分为若干不同的数据区域。这些内存区域各有各的用途，以及创建时间和销毁时间。有的区域随着虚拟机进程的启动而存在，有的区域伴随着用户线程的启动和结束而创建和销毁。

JVM内存区也成为Java运行时数据区域，其中包括：程序计数器，虚拟机栈，本地方法栈，堆，静态方法区，静态常量池等。
</code></pre><blockquote>
<p>PC计数器(Program Counter Register)</p>
</blockquote>
<pre><code>程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码行号指示器。
每个线程都有一个自己的PC计数器，它是私有的，声明周期和线程相同，随着JVM启动而生，JVM关闭而死。当线程执行java方法时，记录其正在执行的虚拟机字节码指令地址，当线程执行Native方法时，计数器记录为空。PC计数器是唯一在JVM规范中没有规定任何OutOfMemoryError的区域。
</code></pre><blockquote>
<p>虚拟机栈</p>
</blockquote>
<pre><code>虚拟机栈是线程私有的内存空间，声明周期和线程相同。线程执行期间，每个方法执行时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
</code></pre><h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><pre><code>局部变量表是一组变量值的存储空间，用于存储方法参数和局部变量。在class文件的方法表的code属性和max_locals指定了该方法所需局部变量表的最大容量。
局部变量表的最小单位是变量槽。规定大小为32位。对于64位的long和double变量而言，虚拟机会为其分配两个连续的Slot空间。
局部变量表在编译期间分配内存空间，可以存放编译期的各种变量类型：
</code></pre><ul>
<li>基本数据类型： boolean，byte，char，short，int，float，long，double</li>
<li>对象引用类型： reference，指向对象起始地址的引用指针</li>
<li>返回地址类型： returnAddress，返回地址的类型</li>
</ul>
<h6 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h6><pre><code>操作数栈是一个后入先出栈。在class文件的code属性的max_stacks指定了执行过程中最大的栈深度。操作数栈也是一个以32字长为单位的数组。
虚拟机在操作数栈中可存储的数据类型：int，long，float，double。reference和returnType(对于byte、short、char类型的值在压入到
操作数栈之前也会被转为int)。
和局部变量表所不同的是，它不是通过索引来访问，而是通过标准的栈操作--压栈和出栈来访问的。
虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。
</code></pre><h6 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h6><pre><code>每个栈帧都包含一个指向运行时常量池中所属的方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。class文件中的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。
符号的引用可通过一下方式生成：
</code></pre><ul>
<li>静态解析： 一部分会在类加载阶段或第一次使用的时候转换为直接引用(如final，static域等)，称为静态解析</li>
<li>动态解析： 另一部分将在每一次的运行期间转换为直接引用，称为动态链接</li>
</ul>
<h6 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h6><pre><code>一个方法开始执行后，只有两种方法可以退出当前方法：
</code></pre><ul>
<li><p>正常返回： 当执行遇到返回指令时，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口，一般来说，调用者的PC计数器可</p>
<pre><code>以作为返回地址
</code></pre></li>
<li><p>异常返回： 当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口。返回地址要通过</p>
<pre><code>异常处理器来确定。
</code></pre><p>  当一个方法返回时，可能依次进行一下操作：</p>
</li>
<li><p>恢复上层方法的局部变量表和操作数栈</p>
</li>
<li>把返回值压入调用者栈帧的操作数栈</li>
<li>将PC计数器的数值指向下一条的方法指令位置</li>
</ul>
<p><strong><em>每一个方法从调用到执行结束的过程，就是对应着一个栈帧在虚拟机栈中的入栈和出栈的过程。</em></strong></p>
<blockquote>
<p>本地方法栈</p>
</blockquote>
<pre><code>本地方法栈和java虚拟机栈发挥的作用非常相似，主要区别在于java虚拟机栈执行的是啊java方法服务，而本地方法栈执行Native方法服务。
</code></pre><blockquote>
<p>堆</p>
</blockquote>
<pre><code>java堆是所有线程共享的最大的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
在java中，堆被分成两个不同的区域，新生代(Young Generation)和老年代(Old Generation)。其中新生代又被划分为三个区域，一个Eden区
和两个Survivor区(From Survivor和To Survivor)。
</code></pre><p><strong><em>新的对象分配是首先放在年轻代的Eden区，Survivor区作为Eden区和老年代的缓冲，在Survivor区的对象经历若干次收集仍然存活的就会被转移到老年代中</em></strong></p>
<blockquote>
<p>方法区</p>
</blockquote>
<pre><code>方法区和java堆一样，为多个线程共享，它用于存储类信息、常量、静态常量和即时编译后的代码等数据。
</code></pre><blockquote>
<p>运行时常量池</p>
</blockquote>
<pre><code>运行时常量池是方法区的一部分，class文件中除了有类的版本，字段，方法和接口等描述信息外，还有一类信息是常量池，用于存储编译期间生成的各种字面量和符号引用。
</code></pre><blockquote>
<p>直接内存</p>
</blockquote>
<pre><code>直接内存不属于虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。
Java NIO允许java程序直接访问直接内存，通常直接内存的速度会优于java堆内存。因此，对于读写频繁、性能要求高的场景，可以考虑使用直接内存。
</code></pre>
      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="javascript:void(0)" class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2019/06/13/杂记/"></a>
      </li>
    
      <li>
        <a href="/2019/06/13/关于java的反射和内省/">java反射和内省</a>
      </li>
    
      <li>
        <a href="/2019/06/13/Spring Doc_01/"></a>
      </li>
    
      <li>
        <a href="/2019/06/13/RabbitMQ_02/">RabbitMQ 配置</a>
      </li>
    
      <li>
        <a href="/2019/06/13/RabbitMQ_01/">Rabbit MQ 使用记录(一)</a>
      </li>
    
  </ul>
</div>


  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2019 Helianthus W
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="bg"></div>
</body>
</html>